<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SQL Functions Repository</title>
        <script src="https://cdn.tailwindcss.com"></script>
   <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    // CAMBIO CLAVE: Importar funciones de Auth con Email/Password
    import { getAuth, signInAnonymously, signInWithCustomToken, signInWithEmailAndPassword, createUserWithEmailAndPassword, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, collection, addDoc, onSnapshot, doc, deleteDoc, updateDoc, getDocs, setDoc, getDoc, query, where } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // Configuración de Firebase (Se mantiene la configuración original del usuario)
    const firebaseConfig = {
        apiKey: "AIzaSyCeD4TAPK2GuW01J5WQl7vJjmJWC671f-Y",
        authDomain: "codigograbado.firebaseapp.com",
        projectId: "codigograbado",
        storageBucket: "codigograbado.firebasestorage.app",
        messagingSenderId: "346430888474",
        appId: "1:346430888474:web:cbaa641fbf4fc62bca4fa3",
        measurementId: "G-626THBS8CJ"
    };
    const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

    let db, auth, userId, loggedInUser = null;
    let functionsList = [];
    let editingId = null;
    let confirmActionCallback = null;
    // Variable para almacenar la acción pendiente de guardar después de la validación de Gemini
    let pendingSaveAction = null; 


    // SE ELIMINAN LAS CREDENCIALES CODIFICADAS DEL SUPER ADMIN
    const SUPER_ADMIN_KEY = 'DT10VazC;#9i'; // Clave Mantenida SOLO para PROMOCIÓN, no para LOGIN
    
    // Rutas de Firestore
    const DB_ROOT = `/artifacts/public/data/aTvZxvxzBtCnCNlURVrQ`;
    const FUNCTIONS_PATH = `${DB_ROOT}/sql_functions`;
    const ADMINS_PATH = `${DB_ROOT}/admins`;
    const LOGS_PATH = `${DB_ROOT}/logs`;
    const NOTIFICATIONS_PATH = `${DB_ROOT}/notifications`;


    // --- Funciones del Modal de Confirmación ---
    const showConfirmModal = (message, onConfirm) => {
        document.getElementById('confirmModalMessage').textContent = message;
        document.getElementById('confirmModal').classList.remove('hidden');
        document.getElementById('confirmModal').classList.add('flex');
        confirmActionCallback = onConfirm;
    };

    const hideConfirmModal = () => {
        document.getElementById('confirmModal').classList.add('hidden');
        document.getElementById('confirmModal').classList.remove('flex');
        confirmActionCallback = null;
    };

    const handleConfirm = (isConfirmed) => {
        if (isConfirmed && confirmActionCallback) {
            confirmActionCallback();
        }
        hideConfirmModal();
    };
    // --- Fin Funciones del Modal de Confirmación ---


    // Función para inicializar Firebase
    const initFirebase = async () => {
        try {
            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app); // Inicializa auth
            
            // Autenticación inicial (Anónima o con Custom Token)
            if (initialAuthToken) {
                await signInWithCustomToken(auth, initialAuthToken);
            } else {
                await signInAnonymously(auth); 
            }
            
            userId = auth.currentUser.uid;
            document.getElementById('userIdDisplay').textContent = `Tu ID de usuario: ${userId}`;
            
            console.log("Firebase inicializado y autenticación exitosa.");
            fetchFunctions();
            fetchNotifications();
        } catch (error) {
            console.error("Error al inicializar Firebase o autenticar:", error);
            showMessage("Error: No se pudo conectar a la base de datos.", 'error');
        }
    };

    const showMessage = (message, type = 'info') => {
        const statusMessage = document.getElementById('statusMessage');
        statusMessage.innerHTML = message;
        statusMessage.className = 'mt-4 text-center p-3 rounded-lg font-medium';
        if (type === 'error') {
            statusMessage.classList.add('bg-rose-200', 'text-rose-800');
        } else if (type === 'success') {
            statusMessage.classList.add('bg-emerald-200', 'text-emerald-800');
        } else {
            statusMessage.classList.add('bg-indigo-200', 'text-indigo-800');
        }
    };

    const fetchFunctions = () => {
        if (!db) return;
        const q = collection(db, FUNCTIONS_PATH);
        onSnapshot(q, (snapshot) => {
            functionsList = snapshot.docs.map(doc => ({
                id: doc.id,
                ...doc.data()
            }));
            displayFunctions();
        }, (error) => {
            console.error("Error al obtener funciones:", error);
            showMessage("Error al cargar las funciones.", 'error');
        });
    };

    const fetchNotifications = () => {
        if (!db || !userId) return;
        const q = collection(db, `${NOTIFICATIONS_PATH}/users/${userId}/notifications`);
        onSnapshot(q, (snapshot) => {
            const notifications = snapshot.docs.map(doc => ({id: doc.id, ...doc.data()}));
            displayNotifications(notifications);
        }, (error) => {
            console.error("Error al obtener notificaciones:", error);
        });
    };

    const addNotification = async (func) => {
        if (!userId) return;
        try {
            await addDoc(collection(db, `${NOTIFICATIONS_PATH}/users/${userId}/notifications`), {
                message: `Se ha agregado una nueva función: "${func.name}" con la descripción: "${func.description}".`,
                createdAt: new Date()
            });
        } catch (e) {
            console.error("Error al agregar notificación:", e);
        }
    };

    const displayNotifications = (notifications) => {
        const notificationsList = document.getElementById('notificationsList');
        if (!notificationsList) return;
        
        notificationsList.innerHTML = '';
        notifications.sort((a, b) => (b.createdAt?.toDate() || 0) - (a.createdAt?.toDate() || 0));
        
        if (notifications.length === 0) {
            notificationsList.innerHTML = '<p class="text-center text-gray-500 text-sm py-2">No hay notificaciones.</p>';
            return;
        }

        notifications.forEach(notif => {
            const date = notif.createdAt ? new Date(notif.createdAt.toDate()).toLocaleString() : 'Fecha desconocida';
            const notifItem = document.createElement('div');
            notifItem.className = 'bg-indigo-200 p-3 rounded-md mb-2';
            notifItem.innerHTML = `<p class="text-indigo-800 text-sm">${notif.message}</p>
                                     <span class="text-xs text-indigo-600">${date}</span>`;
            notificationsList.appendChild(notifItem);
        });
    };

    const displayFunctions = (functionsToDisplay = functionsList) => {
        const listElement = document.getElementById('functionsList');
        const searchList = document.getElementById('searchFunctionsList');
        listElement.innerHTML = '';
        searchList.innerHTML = '';

        const isUserLoggedIn = loggedInUser !== null;

        if (functionsToDisplay.length === 0) {
            listElement.innerHTML = '<p class="text-center text-gray-500">No se encontraron funciones.</p>';
        }

        functionsToDisplay.forEach(func => {
            const funcItem = document.createElement('div');
            funcItem.className = 'bg-gray-200 p-4 rounded-lg shadow-md mb-4';
            funcItem.innerHTML = `
                <h3 class="text-xl font-bold text-gray-800">${func.name}</h3>
                <p class="text-sm text-gray-600 mb-2"><strong>Descripción:</strong> ${func.description}</p>
                <div class="bg-white p-3 rounded-lg border border-gray-400 overflow-x-auto">
                    <pre class="whitespace-pre-wrap font-mono text-gray-800"><code>${func.syntax}</code></pre>
                </div>
                <div class="mt-4 flex space-x-2 ${isUserLoggedIn ? '' : 'hidden'}">
                    <button class="edit-btn bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200 text-sm" data-id="${func.id}">Editar</button>
                    <button class="delete-btn bg-rose-600 hover:bg-rose-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200 text-sm" data-id="${func.id}">Eliminar</button>
                </div>
            `;
            listElement.appendChild(funcItem);

            if (isUserLoggedIn) {
                funcItem.querySelector('.edit-btn').addEventListener('click', () => editFunction(func));
                funcItem.querySelector('.delete-btn').addEventListener('click', () => deleteFunction(func.id));
            }

            const searchItem = document.createElement('li');
            searchItem.className = 'hover:bg-gray-300 cursor-pointer p-2 rounded-md transition duration-150';
            searchItem.textContent = func.name;
            searchItem.onclick = () => {
                document.getElementById('descriptionSearch').value = func.description;
                document.getElementById('descriptionSearch').focus();
                showMessage(`Descripción de la función "${func.name}" cargada en el generador de consultas.`, 'info');
            };
            searchList.appendChild(searchItem);
        });
    };

    // --- FUNCIÓN DE VALIDACIÓN DE GEMINI MODIFICADA (CLAVE ACTUALIZADA) ---
    const validateFunctionWithAI = async (name, description, syntax) => {
        const apiKey = "AIzaSyB0h595ERkhyMS-GCoa5J6zsq_W440R6SM"; // <-- NUEVA CLAVE AQUÍ
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`; // Modelo cambiado a Flash
        
        const prompt = `Eres un experto en SQL y un editor de documentación de alta calidad. Tu tarea es validar una función de SQL que un administrador quiere agregar o editar.

Revisa los siguientes campos:
1.  Nombre de la Función: ${name}
2.  Descripción: ${description}
3.  Sintaxis: ${syntax}

Sigue estos pasos y proporciona la respuesta en formato JSON:
1.  **VERIFICACIÓN BÁSICA (Validación de Sintaxis):** ¿Es la sintaxis un código SQL válido (o un patrón de función SQL válido)? Si NO, establece "valid": false.
2.  **REVISIÓN DE COHERENCIA Y CALIDAD:**
    * Si la sintaxis es válida, revisa si la Descripción es completa y si la Sintaxis es el mejor ejemplo para la función.
    * Si la Descripción o la Sintaxis son subóptimas, genera una o dos sugerencias de mejora concisas.
    * Si hay sugerencias, genera una 'optimizedDescription' y 'optimizedSyntax' mejoradas.
3.  **SALIDA JSON:** Proporciona tu respuesta en el siguiente esquema JSON.

JSON Scheme:
{
  "valid": <boolean, true si la sintaxis es correcta; false si hay un error de sintaxis>,
  "suggestions": <string, Un mensaje conciso de mejora si la sintaxis es válida pero necesita pulirse, o vacío si es perfecto.>,
  "optimizedDescription": <string, La Descripción mejorada. Debe ser igual a la original si no hay sugerencias.>,
  "optimizedSyntax": <string, La Sintaxis mejorada. Debe ser igual a la original si no hay sugerencias.>
}
`;
            
        const payload = {
            contents: [{ parts: [{ text: prompt }] }],
            config: {
                responseMimeType: "application/json", // Forzar la respuesta JSON
            },
        };
            
        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            
            const result = await response.json();
            const text = result?.candidates?.[0]?.content?.parts?.[0]?.text || '';
            
            // Intentar parsear el JSON
            const jsonText = text.replace(/```json|```/g, '').trim();
            const validationData = JSON.parse(jsonText);

            return validationData;
        } catch (error) {
            console.error("Error al validar con IA:", error);
            return { valid: false, suggestions: "No se pudo validar con la IA. Error de conexión o API.", optimizedDescription: description, optimizedSyntax: syntax };
        }
    };

    // --- FUNCIÓN PARA MOSTRAR SUGERENCIAS EN MODAL (NUEVA) ---
    const showGeminiSuggestions = (validationData) => {
        const modal = document.getElementById('geminiModal');
        const messageEl = document.getElementById('geminiModalMessage');
        const suggestionsEl = document.getElementById('geminiSuggestionsBody');
        const acceptBtn = document.getElementById('geminiAcceptBtn');
        const rejectBtn = document.getElementById('geminiRejectBtn');
        
        messageEl.textContent = 'Gemini ha detectado mejoras en la función. ¿Deseas aplicarlas antes de guardar?';
        suggestionsEl.innerHTML = `
            <p class="text-indigo-700 font-semibold mb-2">Sugerencias de Gemini:</p>
            <p class="mb-4 text-gray-700">${validationData.suggestions}</p>
            
            <div class="bg-gray-100 p-3 rounded-lg border border-gray-300">
                <p class="font-bold text-sm text-gray-800">Descripción Optimizada:</p>
                <p class="text-sm text-gray-600">${validationData.optimizedDescription}</p>
            </div>
            <div class="bg-gray-100 p-3 rounded-lg border border-gray-300 mt-2">
                <p class="font-bold text-sm text-gray-800">Sintaxis Optimizada:</p>
                <pre class="text-sm text-gray-600 whitespace-pre-wrap">${validationData.optimizedSyntax}</pre>
            </div>
        `;
            
        modal.classList.remove('hidden');
        modal.classList.add('flex');
            
        // Manejadores de botones para aplicar o rechazar sugerencias
        acceptBtn.onclick = () => {
            document.getElementById('funcDescription').value = validationData.optimizedDescription;
            document.getElementById('funcSyntax').value = validationData.optimizedSyntax;
            hideGeminiModal();
            pendingSaveAction(); // Guarda el formulario con los datos optimizados
        };
            
        rejectBtn.onclick = () => {
            hideGeminiModal();
            pendingSaveAction(); // Guarda el formulario con los datos originales
        };
    };

    const hideGeminiModal = () => {
        document.getElementById('geminiModal').classList.add('hidden');
        document.getElementById('geminiModal').classList.remove('flex');
    };
    // --- FIN FUNCIÓN PARA MOSTRAR SUGERENCIAS EN MODAL ---

    // --- FUNCIÓN DE AGREGAR/ACTUALIZAR MODIFICADA ---
    const addOrUpdateFunction = async (event) => {
        event.preventDefault();
        const name = document.getElementById('funcName').value.trim();
        const description = document.getElementById('funcDescription').value.trim();
        const syntax = document.getElementById('funcSyntax').value.trim();
        const button = document.getElementById('addFunctionButton');
        const originalButtonText = editingId ? 'Actualizar Función' : 'Guardar Función';
            
        if (!loggedInUser) {
            showMessage('Debes iniciar sesión para realizar esta acción.', 'error');
            return;
        }

        if (!name || !description || !syntax) {
            showMessage('Todos los campos son obligatorios.', 'error');
            return;
        }

        // Esta es la función principal de guardado que se llamará después de la validación/sugerencia
        const saveFunction = async () => {
            // Recaptura los valores (pueden haber sido actualizados por el modal)
            const currentName = document.getElementById('funcName').value.trim();
            const currentDescription = document.getElementById('funcDescription').value.trim();
            const currentSyntax = document.getElementById('funcSyntax').value.trim();

            try {
                if (editingId) {
                    await updateDoc(doc(db, FUNCTIONS_PATH, editingId), {
                        name: currentName,
                        description: currentDescription,
                        syntax: currentSyntax,
                    });
                    await addDoc(collection(db, LOGS_PATH), {
                        action: "edited",
                        user: loggedInUser.username,
                        functionName: currentName,
                        timestamp: new Date()
                    });
                    showMessage(`Función actualizada con éxito.`, 'success');
                    editingId = null;
                    document.getElementById('addFunctionButton').textContent = 'Guardar Función';
                } else {
                    await addDoc(collection(db, FUNCTIONS_PATH), {
                        name: currentName,
                        description: currentDescription,
                        syntax: currentSyntax,
                        createdAt: new Date()
                    });
                    await addDoc(collection(db, LOGS_PATH), {
                        action: "added",
                        user: loggedInUser.username,
                        functionName: currentName,
                        timestamp: new Date()
                    });
                    showMessage(`Función agregada con éxito.`, 'success');
                    await addNotification({name: currentName, description: currentDescription, syntax: currentSyntax});
                }
                document.getElementById('addFunctionForm').reset();
            } catch (e) {
                console.error("Error al agregar/actualizar documento: ", e);
                showMessage("Error al guardar la función. Verifica la consola de Firebase.", 'error');
            } finally {
                button.textContent = originalButtonText;
                button.disabled = false;
            }
        };


        // --- FLUJO DE VALIDACIÓN INICIAL ---
        button.textContent = 'Validando con IA...';
        button.disabled = true;

        const validationResult = await validateFunctionWithAI(name, description, syntax);

        if (!validationResult.valid) {
            // Si hay un error de sintaxis FATAL, se cancela el proceso
            showMessage(`Error al agregar la información. Error de sintaxis: ${validationResult.suggestions || 'Sintaxis inválida.'}`, 'error');
            button.textContent = originalButtonText;
            button.disabled = false;
            return;
        }

        if (validationResult.suggestions && validationResult.suggestions.trim() !== '') {
            // Si hay sugerencias de mejora, mostrar modal
            pendingSaveAction = saveFunction; // Almacenar la acción de guardado
            showGeminiSuggestions(validationResult);
        } else {
            // Si es válido y no hay sugerencias, guardar directamente
            saveFunction();
        }
    };
    // --- FIN FUNCIÓN DE AGREGAR/ACTUALIZAR MODIFICADA ---

    const editFunction = (func) => {
        editingId = func.id;
        document.getElementById('funcName').value = func.name;
        document.getElementById('funcDescription').value = func.description;
        document.getElementById('funcSyntax').value = func.syntax;
        document.getElementById('addFunctionButton').textContent = 'Actualizar Función';
        document.getElementById('addFunctionSection').scrollIntoView({ behavior: 'smooth' });
    };

    const deleteFunction = async (id) => {
        if (!loggedInUser) {
            showMessage('Debes iniciar sesión para realizar esta acción.', 'error');
            return;
        }
        
        showConfirmModal('¿Estás seguro de que quieres eliminar esta función? Esta acción no se puede deshacer.', async () => {
            try {
                const docRef = doc(db, FUNCTIONS_PATH, id);
                const funcSnap = await getDoc(docRef);
                if (funcSnap.exists()) {
                    await deleteDoc(docRef);
                    await addDoc(collection(db, LOGS_PATH), {
                        action: "deleted",
                        user: loggedInUser.username,
                        functionName: funcSnap.data().name,
                        timestamp: new Date()
                    });
                    showMessage('Función eliminada con éxito.', 'success');
                }
            } catch (e) {
                console.error("Error al eliminar documento: ", e);
                showMessage("Error al eliminar la función.", 'error');
            }
        });
    };

    // Función de Creación de Administrador
    const createAdmin = async (event) => {
        event.preventDefault();
        const newAdminEmail = document.getElementById('newAdminEmail').value.trim();
        const newAdminPassword = document.getElementById('newAdminPassword').value;
        const newAdminUsername = document.getElementById('newAdminUsername').value.trim();
        const secretKey = document.getElementById('secretKey').value;
        const adminMessage = document.getElementById('adminMessage');

        adminMessage.textContent = '';
        adminMessage.className = 'mt-4 text-center text-sm';
        
        // La clave secreta ahora solo es obligatoria si el email ya existe
        const isPromotingExistingUser = secretKey === SUPER_ADMIN_KEY;
        
        if (!newAdminEmail || !newAdminPassword || !newAdminUsername) {
            adminMessage.textContent = 'Todos los campos son obligatorios.';
            adminMessage.classList.add('text-rose-500');
            return;
        }
        
        let uid = null;

        try {
            // 1. Intentar crear usuario en Firebase Authentication
            const userCredential = await createUserWithEmailAndPassword(auth, newAdminEmail, newAdminPassword);
            uid = userCredential.user.uid;
        } catch (e) {
            if (e.code === 'auth/email-already-in-use') {
                // Si el email ya está en uso, intentamos obtener el UID SÓLO si se proporciona la clave de promoción.
                if (isPromotingExistingUser) {
                    try {
                        // Temporalmente loguea al usuario para obtener el UID
                        const userCredential = await signInWithEmailAndPassword(auth, newAdminEmail, newAdminPassword);
                        uid = userCredential.user.uid;
                        // Cierra la sesión temporal para no interrumpir al Admin que está creando la cuenta.
                        await signOut(auth); 
                        adminMessage.textContent = 'Advertencia: El email ya existía. Se asignarán permisos de administrador.';
                    } catch (signInError) {
                         let displayError = 'Error: El email ya está registrado, pero la contraseña no coincide. No se puede obtener el UID para asignar permisos.';
                         adminMessage.textContent = displayError;
                         adminMessage.classList.add('text-rose-500');
                         return;
                    }
                } else {
                    adminMessage.textContent = 'Error: El email ya está registrado. Para promocionar a un usuario existente, ingrese la clave secreta.';
                    adminMessage.classList.add('text-rose-500');
                    return;
                }
            } else if (e.code === 'auth/weak-password') {
                adminMessage.textContent = 'Error: La contraseña debe tener al menos 6 caracteres.';
                adminMessage.classList.add('text-rose-500');
                return;
            } else {
                console.error("Error al crear usuario Auth:", e);
                adminMessage.textContent = `Error (${e.code || 'unknown-error'}): No se pudo crear la cuenta de usuario.`;
                adminMessage.classList.add('text-rose-500');
                return;
            }
        }
        
        if (!uid) { return; } // Salir si no se pudo obtener el UID.


            // 2. Registrar el rol en Firestore usando el UID (tanto para usuarios nuevos como existentes)
            try {
                await setDoc(doc(db, ADMINS_PATH, uid), {
                    uid: uid,
                    username: newAdminUsername,
                    email: newAdminEmail,
                    isAdmin: true, // Establecer como true para que sea admin de Firestore
                    lastLogin: null
                }, { merge: true }); // Usar merge: true para no sobrescribir lastLogin si ya existe.

                if (!adminMessage.classList.contains('text-yellow-500')) {
                    adminMessage.textContent = `Administrador ${newAdminUsername} creado con éxito. Ahora puede iniciar sesión con su email y contraseña.`;
                    adminMessage.classList.add('text-emerald-500');
                }
                document.getElementById('createAdminForm').reset();
            } catch (e) {
                console.error("Error al registrar administrador en Firestore:", e);
                adminMessage.textContent = 'Error: Se creó la cuenta de Auth, pero falló el registro de permisos en Firestore.';
                adminMessage.classList.add('text-rose-500');
            }
        };

        const logout = async () => {
            try {
                // Siempre cierra la sesión de Firebase Auth, si existe.
                if (auth.currentUser) {
                    await signOut(auth);
                }
                
                // Reseteamos el estado de la aplicación
                loggedInUser = null; 

                // Ocultar secciones de administración
                document.getElementById('addFunctionSection').classList.add('hidden');
                document.getElementById('fixErrorSection').classList.add('hidden');
                document.getElementById('adminManagementSection').classList.add('hidden');
                document.getElementById('notificationsSection').classList.add('hidden');
                document.getElementById('logoutButton').classList.add('hidden');
                document.getElementById('welcomeMessage').classList.add('hidden');

                // Volver a iniciar sesión anónima para acceder a funciones de lectura pública
                await signInAnonymously(auth);
                userId = auth.currentUser.uid;
                document.getElementById('userIdDisplay').textContent = `Tu ID de usuario: ${userId}`;

                // Mostrar sección de login y refrescar lista para ocultar botones de editar/eliminar
                document.getElementById('loginSection').classList.remove('hidden');
                displayFunctions(); 

                showMessage('Sesión cerrada correctamente.', 'info');
            } catch (error) {
                console.error("Error al cerrar sesión o al re-autenticar anónimamente:", error);
                showMessage('Error al cerrar sesión.', 'error');
            }
        };

        // MODIFICACIÓN CRÍTICA: Se elimina la verificación estricta del rol de Firestore.
        const login = async (event) => {
            event.preventDefault();
            const loginEmail = document.getElementById('loginEmail').value.trim();
            const loginPassword = document.getElementById('loginPassword').value;
            const loginMessage = document.getElementById('loginMessage');
            
            loginMessage.textContent = '';
            loggedInUser = null; 
            
            let userFound = false;
            let uid = null;

            try {
                // 1. Intento de inicio de sesión de Firebase Auth (Email/Password)
                const userCredential = await signInWithEmailAndPassword(auth, loginEmail, loginPassword);
                const user = userCredential.user;
                uid = user.uid;

                // 2. ASUMIMOS QUE EL USUARIO AUTENTICADO ES EL ADMIN (QUITANDO LA VERIFICACIÓN DEL ROL)
                loggedInUser = { 
                    uid: uid,
                    // Usamos la parte del email antes del @ como nombre de usuario por defecto
                    username: loginEmail.split('@')[0], 
                    isAdmin: true, // Asumir permisos de administrador
                    lastLogin: null // Se obtendrá y actualizará después
                };
                userFound = true;

                // Opcional: Intento de obtener el documento de Firestore si existiera (para 'lastLogin' y 'username'), 
                // pero NO fallamos si no existe el documento de rol.
                try {
                    const docRef = doc(db, ADMINS_PATH, uid);
                    const docSnap = await getDoc(docRef);
                    if (docSnap.exists()) {
                        loggedInUser.lastLogin = docSnap.data().lastLogin;
                        loggedInUser.username = docSnap.data().username || loggedInUser.username;
                    }
                } catch (e) {
                    console.warn("No se pudo obtener el documento de admin para la verificación de logs.", e);
                }

            } catch (e) {
                console.error("Error de autenticación:", e);
                const errorCode = e.code || '';
                
                // Manejo de errores comunes de Firebase Auth
                if (errorCode === 'auth/invalid-credential' || errorCode === 'auth/user-not-found' || errorCode === 'auth/wrong-password') {
                    loginMessage.textContent = 'Credenciales incorrectas.';
                } else {
                    loginMessage.textContent = 'Error de autenticación. Verifica tus datos.';
                }
                loginMessage.classList.add('text-rose-500');
                return;
            }


            if (userFound) {
                // La sesión de Firebase Auth ya está activa (userCredential la inició)
                document.getElementById('loginSection').classList.add('hidden');
                document.getElementById('logoutButton').classList.remove('hidden');
                document.getElementById('addFunctionSection').classList.remove('hidden');
                document.getElementById('fixErrorSection').classList.remove('hidden');
                
                displayFunctions(); // Refresca botones de editar/eliminar

    1. **Cargar la librería:** Agregamos `<script src="https://cdn.tailwindcss.com"></script>` al `<head>`.
    2. **Establecer el fondo y texto base:** Agregamos `class="bg-gray-100 font-sans leading-normal tracking-normal text-gray-800"` a la etiqueta `<body>`.

Aquí está el **código HTML completo y corregido**:

```html
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SQL Functions Repository</title>
        <script src="[https://cdn.tailwindcss.com](https://cdn.tailwindcss.com)"></script>
   <script type="module">
    import { initializeApp } from "[https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js](https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js)";
    // CAMBIO CLAVE: Importar funciones de Auth con Email/Password
    import { getAuth, signInAnonymously, signInWithCustomToken, signInWithEmailAndPassword, createUserWithEmailAndPassword, signOut } from "[https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js](https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js)";
    import { getFirestore, collection, addDoc, onSnapshot, doc, deleteDoc, updateDoc, getDocs, setDoc, getDoc, query, where } from "[https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js](https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js)";

    // Configuración de Firebase (Se mantiene la configuración original del usuario)
    const firebaseConfig = {
        apiKey: "AIzaSyCeD4TAPK2GuW01J5WQl7vJjmJWC671f-Y",
        authDomain: "codigograbado.firebaseapp.com",
        projectId: "codigograbado",
        storageBucket: "codigograbado.firebasestorage.app",
        messagingSenderId: "346430888474",
        appId: "1:346430888474:web:cbaa641fbf4fc62bca4fa3",
        measurementId: "G-626THBS8CJ"
    };
    const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

    let db, auth, userId, loggedInUser = null;
    let functionsList = [];
    let editingId = null;
    let confirmActionCallback = null;
    // Variable para almacenar la acción pendiente de guardar después de la validación de Gemini
    let pendingSaveAction = null; 


    // SE ELIMINAN LAS CREDENCIALES CODIFICADAS DEL SUPER ADMIN
    const SUPER_ADMIN_KEY = 'DT10VazC;#9i'; // Clave Mantenida SOLO para PROMOCIÓN, no para LOGIN
    
    // Rutas de Firestore
    const DB_ROOT = `/artifacts/public/data/aTvZxvxzBtCnCNlURVrQ`;
    const FUNCTIONS_PATH = `${DB_ROOT}/sql_functions`;
    const ADMINS_PATH = `${DB_ROOT}/admins`;
    const LOGS_PATH = `${DB_ROOT}/logs`;
    const NOTIFICATIONS_PATH = `${DB_ROOT}/notifications`;


    // --- Funciones del Modal de Confirmación ---
    const showConfirmModal = (message, onConfirm) => {
        document.getElementById('confirmModalMessage').textContent = message;
        document.getElementById('confirmModal').classList.remove('hidden');
        document.getElementById('confirmModal').classList.add('flex');
        confirmActionCallback = onConfirm;
    };

    const hideConfirmModal = () => {
        document.getElementById('confirmModal').classList.add('hidden');
        document.getElementById('confirmModal').classList.remove('flex');
        confirmActionCallback = null;
    };

    const handleConfirm = (isConfirmed) => {
        if (isConfirmed && confirmActionCallback) {
            confirmActionCallback();
        }
        hideConfirmModal();
    };
    // --- Fin Funciones del Modal de Confirmación ---


    // Función para inicializar Firebase
    const initFirebase = async () => {
        try {
            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app); // Inicializa auth
            
            // Autenticación inicial (Anónima o con Custom Token)
            if (initialAuthToken) {
                await signInWithCustomToken(auth, initialAuthToken);
            } else {
                await signInAnonymously(auth); 
            }
            
            userId = auth.currentUser.uid;
            document.getElementById('userIdDisplay').textContent = `Tu ID de usuario: ${userId}`;
            
            console.log("Firebase inicializado y autenticación exitosa.");
            fetchFunctions();
            fetchNotifications();
        } catch (error) {
            console.error("Error al inicializar Firebase o autenticar:", error);
            showMessage("Error: No se pudo conectar a la base de datos.", 'error');
        }
    };

    const showMessage = (message, type = 'info') => {
        const statusMessage = document.getElementById('statusMessage');
        statusMessage.innerHTML = message;
        statusMessage.className = 'mt-4 text-center p-3 rounded-lg font-medium';
        if (type === 'error') {
            statusMessage.classList.add('bg-rose-200', 'text-rose-800');
        } else if (type === 'success') {
            statusMessage.classList.add('bg-emerald-200', 'text-emerald-800');
        } else {
            statusMessage.classList.add('bg-indigo-200', 'text-indigo-800');
        }
    };

    const fetchFunctions = () => {
        if (!db) return;
        const q = collection(db, FUNCTIONS_PATH);
        onSnapshot(q, (snapshot) => {
            functionsList = snapshot.docs.map(doc => ({
                id: doc.id,
                ...doc.data()
            }));
            displayFunctions();
        }, (error) => {
            console.error("Error al obtener funciones:", error);
            showMessage("Error al cargar las funciones.", 'error');
        });
    };

    const fetchNotifications = () => {
        if (!db || !userId) return;
        const q = collection(db, `${NOTIFICATIONS_PATH}/users/${userId}/notifications`);
        onSnapshot(q, (snapshot) => {
            const notifications = snapshot.docs.map(doc => ({id: doc.id, ...doc.data()}));
            displayNotifications(notifications);
        }, (error) => {
            console.error("Error al obtener notificaciones:", error);
        });
    };

    const addNotification = async (func) => {
        if (!userId) return;
        try {
            await addDoc(collection(db, `${NOTIFICATIONS_PATH}/users/${userId}/notifications`), {
                message: `Se ha agregado una nueva función: "${func.name}" con la descripción: "${func.description}".`,
                createdAt: new Date()
            });
        } catch (e) {
            console.error("Error al agregar notificación:", e);
        }
    };

    const displayNotifications = (notifications) => {
        const notificationsList = document.getElementById('notificationsList');
        if (!notificationsList) return;
        
        notificationsList.innerHTML = '';
        notifications.sort((a, b) => (b.createdAt?.toDate() || 0) - (a.createdAt?.toDate() || 0));
        
        if (notifications.length === 0) {
            notificationsList.innerHTML = '<p class="text-center text-gray-500 text-sm py-2">No hay notificaciones.</p>';
            return;
        }

        notifications.forEach(notif => {
            const date = notif.createdAt ? new Date(notif.createdAt.toDate()).toLocaleString() : 'Fecha desconocida';
            const notifItem = document.createElement('div');
            notifItem.className = 'bg-indigo-200 p-3 rounded-md mb-2';
            notifItem.innerHTML = `<p class="text-indigo-800 text-sm">${notif.message}</p>
                                     <span class="text-xs text-indigo-600">${date}</span>`;
            notificationsList.appendChild(notifItem);
        });
    };

    const displayFunctions = (functionsToDisplay = functionsList) => {
        const listElement = document.getElementById('functionsList');
        const searchList = document.getElementById('searchFunctionsList');
        listElement.innerHTML = '';
        searchList.innerHTML = '';

        const isUserLoggedIn = loggedInUser !== null;

        if (functionsToDisplay.length === 0) {
            listElement.innerHTML = '<p class="text-center text-gray-500">No se encontraron funciones.</p>';
        }

        functionsToDisplay.forEach(func => {
            const funcItem = document.createElement('div');
            funcItem.className = 'bg-gray-200 p-4 rounded-lg shadow-md mb-4';
            funcItem.innerHTML = `
                <h3 class="text-xl font-bold text-gray-800">${func.name}</h3>
                <p class="text-sm text-gray-600 mb-2"><strong>Descripción:</strong> ${func.description}</p>
                <div class="bg-white p-3 rounded-lg border border-gray-400 overflow-x-auto">
                    <pre class="whitespace-pre-wrap font-mono text-gray-800"><code>${func.syntax}</code></pre>
                </div>
                <div class="mt-4 flex space-x-2 ${isUserLoggedIn ? '' : 'hidden'}">
                    <button class="edit-btn bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200 text-sm" data-id="${func.id}">Editar</button>
                    <button class="delete-btn bg-rose-600 hover:bg-rose-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200 text-sm" data-id="${func.id}">Eliminar</button>
                </div>
            `;
            listElement.appendChild(funcItem);

            if (isUserLoggedIn) {
                funcItem.querySelector('.edit-btn').addEventListener('click', () => editFunction(func));
                funcItem.querySelector('.delete-btn').addEventListener('click', () => deleteFunction(func.id));
            }

            const searchItem = document.createElement('li');
            searchItem.className = 'hover:bg-gray-300 cursor-pointer p-2 rounded-md transition duration-150';
            searchItem.textContent = func.name;
            searchItem.onclick = () => {
                document.getElementById('descriptionSearch').value = func.description;
                document.getElementById('descriptionSearch').focus();
                showMessage(`Descripción de la función "${func.name}" cargada en el generador de consultas.`, 'info');
            };
            searchList.appendChild(searchItem);
        });
    };

    // --- FUNCIÓN DE VALIDACIÓN DE GEMINI MODIFICADA (CLAVE ACTUALIZADA) ---
    const validateFunctionWithAI = async (name, description, syntax) => {
        const apiKey = "AIzaSyB0h595ERkhyMS-GCoa5J6zsq_W440R6SM"; // <-- NUEVA CLAVE AQUÍ
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`; // Modelo cambiado a Flash
        
        const prompt = `Eres un experto en SQL y un editor de documentación de alta calidad. Tu tarea es validar una función de SQL que un administrador quiere agregar o editar.

Revisa los siguientes campos:
1.  Nombre de la Función: ${name}
2.  Descripción: ${description}
3.  Sintaxis: ${syntax}

Sigue estos pasos y proporciona la respuesta en formato JSON:
1.  **VERIFICACIÓN BÁSICA (Validación de Sintaxis):** ¿Es la sintaxis un código SQL válido (o un patrón de función SQL válido)? Si NO, establece "valid": false.
2.  **REVISIÓN DE COHERENCIA Y CALIDAD:**
    * Si la sintaxis es válida, revisa si la Descripción es completa y si la Sintaxis es el mejor ejemplo para la función.
    * Si la Descripción o la Sintaxis son subóptimas, genera una o dos sugerencias de mejora concisas.
    * Si hay sugerencias, genera una 'optimizedDescription' y 'optimizedSyntax' mejoradas.
3.  **SALIDA JSON:** Proporciona tu respuesta en el siguiente esquema JSON.

JSON Scheme:
{
  "valid": <boolean, true si la sintaxis es correcta; false si hay un error de sintaxis>,
  "suggestions": <string, Un mensaje conciso de mejora si la sintaxis es válida pero necesita pulirse, o vacío si es perfecto.>,
  "optimizedDescription": <string, La Descripción mejorada. Debe ser igual a la original si no hay sugerencias.>,
  "optimizedSyntax": <string, La Sintaxis mejorada. Debe ser igual a la original si no hay sugerencias.>
}
`;
            
        const payload = {
            contents: [{ parts: [{ text: prompt }] }],
            config: {
                responseMimeType: "application/json", // Forzar la respuesta JSON
            },
        };
            
        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            
            const result = await response.json();
            const text = result?.candidates?.[0]?.content?.parts?.[0]?.text || '';
            
            // Intentar parsear el JSON
            const jsonText = text.replace(/```json|```/g, '').trim();
            const validationData = JSON.parse(jsonText);

            return validationData;
        } catch (error) {
            console.error("Error al validar con IA:", error);
            return { valid: false, suggestions: "No se pudo validar con la IA. Error de conexión o API.", optimizedDescription: description, optimizedSyntax: syntax };
        }
    };

    // --- FUNCIÓN PARA MOSTRAR SUGERENCIAS EN MODAL (NUEVA) ---
    const showGeminiSuggestions = (validationData) => {
        const modal = document.getElementById('geminiModal');
        const messageEl = document.getElementById('geminiModalMessage');
        const suggestionsEl = document.getElementById('geminiSuggestionsBody');
        const acceptBtn = document.getElementById('geminiAcceptBtn');
        const rejectBtn = document.getElementById('geminiRejectBtn');
        
        messageEl.textContent = 'Gemini ha detectado mejoras en la función. ¿Deseas aplicarlas antes de guardar?';
        suggestionsEl.innerHTML = `
            <p class="text-indigo-700 font-semibold mb-2">Sugerencias de Gemini:</p>
            <p class="mb-4 text-gray-700">${validationData.suggestions}</p>
            
            <div class="bg-gray-100 p-3 rounded-lg border border-gray-300">
                <p class="font-bold text-sm text-gray-800">Descripción Optimizada:</p>
                <p class="text-sm text-gray-600">${validationData.optimizedDescription}</p>
            </div>
            <div class="bg-gray-100 p-3 rounded-lg border border-gray-300 mt-2">
                <p class="font-bold text-sm text-gray-800">Sintaxis Optimizada:</p>
                <pre class="text-sm text-gray-600 whitespace-pre-wrap">${validationData.optimizedSyntax}</pre>
            </div>
        `;
            
        modal.classList.remove('hidden');
        modal.classList.add('flex');
            
        // Manejadores de botones para aplicar o rechazar sugerencias
        acceptBtn.onclick = () => {
            document.getElementById('funcDescription').value = validationData.optimizedDescription;
            document.getElementById('funcSyntax').value = validationData.optimizedSyntax;
            hideGeminiModal();
            pendingSaveAction(); // Guarda el formulario con los datos optimizados
        };
            
        rejectBtn.onclick = () => {
            hideGeminiModal();
            pendingSaveAction(); // Guarda el formulario con los datos originales
        };
    };

    const hideGeminiModal = () => {
        document.getElementById('geminiModal').classList.add('hidden');
        document.getElementById('geminiModal').classList.remove('flex');
    };
    // --- FIN FUNCIÓN PARA MOSTRAR SUGERENCIAS EN MODAL ---

    // --- FUNCIÓN DE AGREGAR/ACTUALIZAR MODIFICADA ---
    const addOrUpdateFunction = async (event) => {
        event.preventDefault();
        const name = document.getElementById('funcName').value.trim();
        const description = document.getElementById('funcDescription').value.trim();
        const syntax = document.getElementById('funcSyntax').value.trim();
        const button = document.getElementById('addFunctionButton');
        const originalButtonText = editingId ? 'Actualizar Función' : 'Guardar Función';
            
        if (!loggedInUser) {
            showMessage('Debes iniciar sesión para realizar esta acción.', 'error');
            return;
        }

        if (!name || !description || !syntax) {
            showMessage('Todos los campos son obligatorios.', 'error');
            return;
        }

        // Esta es la función principal de guardado que se llamará después de la validación/sugerencia
        const saveFunction = async () => {
            // Recaptura los valores (pueden haber sido actualizados por el modal)
            const currentName = document.getElementById('funcName').value.trim();
            const currentDescription = document.getElementById('funcDescription').value.trim();
            const currentSyntax = document.getElementById('funcSyntax').value.trim();

            try {
                if (editingId) {
                    await updateDoc(doc(db, FUNCTIONS_PATH, editingId), {
                        name: currentName,
                        description: currentDescription,
                        syntax: currentSyntax,
                    });
                    await addDoc(collection(db, LOGS_PATH), {
                        action: "edited",
                        user: loggedInUser.username,
                        functionName: currentName,
                        timestamp: new Date()
                    });
                    showMessage(`Función actualizada con éxito.`, 'success');
                    editingId = null;
                    document.getElementById('addFunctionButton').textContent = 'Guardar Función';
                } else {
                    await addDoc(collection(db, FUNCTIONS_PATH), {
                        name: currentName,
                        description: currentDescription,
                        syntax: currentSyntax,
                        createdAt: new Date()
                    });
                    await addDoc(collection(db, LOGS_PATH), {
                        action: "added",
                        user: loggedInUser.username,
                        functionName: currentName,
                        timestamp: new Date()
                    });
                    showMessage(`Función agregada con éxito.`, 'success');
                    await addNotification({name: currentName, description: currentDescription, syntax: currentSyntax});
                }
                document.getElementById('addFunctionForm').reset();
            } catch (e) {
                console.error("Error al agregar/actualizar documento: ", e);
                showMessage("Error al guardar la función. Verifica la consola de Firebase.", 'error');
            } finally {
                button.textContent = originalButtonText;
                button.disabled = false;
            }
        };


        // --- FLUJO DE VALIDACIÓN INICIAL ---
        button.textContent = 'Validando con IA...';
        button.disabled = true;

        const validationResult = await validateFunctionWithAI(name, description, syntax);

        if (!validationResult.valid) {
            // Si hay un error de sintaxis FATAL, se cancela el proceso
            showMessage(`Error al agregar la información. Error de sintaxis: ${validationResult.suggestions || 'Sintaxis inválida.'}`, 'error');
            button.textContent = originalButtonText;
            button.disabled = false;
            return;
        }

        if (validationResult.suggestions && validationResult.suggestions.trim() !== '') {
            // Si hay sugerencias de mejora, mostrar modal
            pendingSaveAction = saveFunction; // Almacenar la acción de guardado
            showGeminiSuggestions(validationResult);
        } else {
            // Si es válido y no hay sugerencias, guardar directamente
            saveFunction();
        }
    };
    // --- FIN FUNCIÓN DE AGREGAR/ACTUALIZAR MODIFICADA ---

    const editFunction = (func) => {
        editingId = func.id;
        document.getElementById('funcName').value = func.name;
        document.getElementById('funcDescription').value = func.description;
        document.getElementById('funcSyntax').value = func.syntax;
        document.getElementById('addFunctionButton').textContent = 'Actualizar Función';
        document.getElementById('addFunctionSection').scrollIntoView({ behavior: 'smooth' });
    };

    const deleteFunction = async (id) => {
        if (!loggedInUser) {
            showMessage('Debes iniciar sesión para realizar esta acción.', 'error');
            return;
        }
        
        showConfirmModal('¿Estás seguro de que quieres eliminar esta función? Esta acción no se puede deshacer.', async () => {
            try {
                const docRef = doc(db, FUNCTIONS_PATH, id);
                const funcSnap = await getDoc(docRef);
                if (funcSnap.exists()) {
                    await deleteDoc(docRef);
                    await addDoc(collection(db, LOGS_PATH), {
                        action: "deleted",
                        user: loggedInUser.username,
                        functionName: funcSnap.data().name,
                        timestamp: new Date()
                    });
                    showMessage('Función eliminada con éxito.', 'success');
                }
            } catch (e) {
                console.error("Error al eliminar documento: ", e);
                showMessage("Error al eliminar la función.", 'error');
            }
        });
    };

    // Función de Creación de Administrador
    const createAdmin = async (event) => {
        event.preventDefault();
        const newAdminEmail = document.getElementById('newAdminEmail').value.trim();
        const newAdminPassword = document.getElementById('newAdminPassword').value;
        const newAdminUsername = document.getElementById('newAdminUsername').value.trim();
        const secretKey = document.getElementById('secretKey').value;
        const adminMessage = document.getElementById('adminMessage');

        adminMessage.textContent = '';
        adminMessage.className = 'mt-4 text-center text-sm';
        
        // La clave secreta ahora solo es obligatoria si el email ya existe
        const isPromotingExistingUser = secretKey === SUPER_ADMIN_KEY;
        
        if (!newAdminEmail || !newAdminPassword || !newAdminUsername) {
            adminMessage.textContent = 'Todos los campos son obligatorios.';
            adminMessage.classList.add('text-rose-500');
            return;
        }
        
        let uid = null;

        try {
            // 1. Intentar crear usuario en Firebase Authentication
            const userCredential = await createUserWithEmailAndPassword(auth, newAdminEmail, newAdminPassword);
            uid = userCredential.user.uid;
        } catch (e) {
            if (e.code === 'auth/email-already-in-use') {
                // Si el email ya está en uso, intentamos obtener el UID SÓLO si se proporciona la clave de promoción.
                if (isPromotingExistingUser) {
                    try {
                        // Temporalmente loguea al usuario para obtener el UID
                        const userCredential = await signInWithEmailAndPassword(auth, newAdminEmail, newAdminPassword);
                        uid = userCredential.user.uid;
                        // Cierra la sesión temporal para no interrumpir al Admin que está creando la cuenta.
                        await signOut(auth); 
                        adminMessage.textContent = 'Advertencia: El email ya existía. Se asignarán permisos de administrador.';
                    } catch (signInError) {
                         let displayError = 'Error: El email ya está registrado, pero la contraseña no coincide. No se puede obtener el UID para asignar permisos.';
                         adminMessage.textContent = displayError;
                         adminMessage.classList.add('text-rose-500');
                         return;
                    }
                } else {
                    adminMessage.textContent = 'Error: El email ya está registrado. Para promocionar a un usuario existente, ingrese la clave secreta.';
                    adminMessage.classList.add('text-rose-500');
                    return;
                }
            } else if (e.code === 'auth/weak-password') {
                adminMessage.textContent = 'Error: La contraseña debe tener al menos 6 caracteres.';
                adminMessage.classList.add('text-rose-500');
                return;
            } else {
                console.error("Error al crear usuario Auth:", e);
                adminMessage.textContent = `Error (${e.code || 'unknown-error'}): No se pudo crear la cuenta de usuario.`;
                adminMessage.classList.add('text-rose-500');
                return;
            }
        }
        
        if (!uid) { return; } // Salir si no se pudo obtener el UID.


            // 2. Registrar el rol en Firestore usando el UID (tanto para usuarios nuevos como existentes)
            try {
                await setDoc(doc(db, ADMINS_PATH, uid), {
                    uid: uid,
                    username: newAdminUsername,
                    email: newAdminEmail,
                    isAdmin: true, // Establecer como true para que sea admin de Firestore
                    lastLogin: null
                }, { merge: true }); // Usar merge: true para no sobrescribir lastLogin si ya existe.

                if (!adminMessage.classList.contains('text-yellow-500')) {
                    adminMessage.textContent = `Administrador ${newAdminUsername} creado con éxito. Ahora puede iniciar sesión con su email y contraseña.`;
                    adminMessage.classList.add('text-emerald-500');
                }
                document.getElementById('createAdminForm').reset();
            } catch (e) {
                console.error("Error al registrar administrador en Firestore:", e);
                adminMessage.textContent = 'Error: Se creó la cuenta de Auth, pero falló el registro de permisos en Firestore.';
                adminMessage.classList.add('text-rose-500');
            }
        };

        const logout = async () => {
            try {
                // Siempre cierra la sesión de Firebase Auth, si existe.
                if (auth.currentUser) {
                    await signOut(auth);
                }
                
                // Reseteamos el estado de la aplicación
                loggedInUser = null; 

                // Ocultar secciones de administración
                document.getElementById('addFunctionSection').classList.add('hidden');
                document.getElementById('fixErrorSection').classList.add('hidden');
                document.getElementById('adminManagementSection').classList.add('hidden');
                document.getElementById('notificationsSection').classList.add('hidden');
                document.getElementById('logoutButton').classList.add('hidden');
                document.getElementById('welcomeMessage').classList.add('hidden');

                // Volver a iniciar sesión anónima para acceder a funciones de lectura pública
                await signInAnonymously(auth);
                userId = auth.currentUser.uid;
                document.getElementById('userIdDisplay').textContent = `Tu ID de usuario: ${userId}`;

                // Mostrar sección de login y refrescar lista para ocultar botones de editar/eliminar
                document.getElementById('loginSection').classList.remove('hidden');
                displayFunctions(); 

                showMessage('Sesión cerrada correctamente.', 'info');
            } catch (error) {
                console.error("Error al cerrar sesión o al re-autenticar anónimamente:", error);
                showMessage('Error al cerrar sesión.', 'error');
            }
        };

        // MODIFICACIÓN CRÍTICA: Se elimina la verificación estricta del rol de Firestore.
        const login = async (event) => {
            event.preventDefault();
            const loginEmail = document.getElementById('loginEmail').value.trim();
            const loginPassword = document.getElementById('loginPassword').value;
            const loginMessage = document.getElementById('loginMessage');
            
            loginMessage.textContent = '';
            loggedInUser = null; 
            
            let userFound = false;
            let uid = null;

            try {
                // 1. Intento de inicio de sesión de Firebase Auth (Email/Password)
                const userCredential = await signInWithEmailAndPassword(auth, loginEmail, loginPassword);
                const user = userCredential.user;
                uid = user.uid;

                // 2. ASUMIMOS QUE EL USUARIO AUTENTICADO ES EL ADMIN (QUITANDO LA VERIFICACIÓN DEL ROL)
                loggedInUser = { 
                    uid: uid,
                    // Usamos la parte del email antes del @ como nombre de usuario por defecto
                    username: loginEmail.split('@')[0], 
                    isAdmin: true, // Asumir permisos de administrador
                    lastLogin: null // Se obtendrá y actualizará después
                };
                userFound = true;

                // Opcional: Intento de obtener el documento de Firestore si existiera (para 'lastLogin' y 'username'), 
                // pero NO fallamos si no existe el documento de rol.
                try {
                    const docRef = doc(db, ADMINS_PATH, uid);
                    const docSnap = await getDoc(docRef);
                    if (docSnap.exists()) {
                        loggedInUser.lastLogin = docSnap.data().lastLogin;
                        loggedInUser.username = docSnap.data().username || loggedInUser.username;
                    }
                } catch (e) {
                    console.warn("No se pudo obtener el documento de admin para la verificación de logs.", e);
                }

            } catch (e) {
                console.error("Error de autenticación:", e);
                const errorCode = e.code || '';
                
                // Manejo de errores comunes de Firebase Auth
                if (errorCode === 'auth/invalid-credential' || errorCode === 'auth/user-not-found' || errorCode === 'auth/wrong-password') {
                    loginMessage.textContent = 'Credenciales incorrectas.';
                } else {
                    loginMessage.textContent = 'Error de autenticación. Verifica tus datos.';
                }
                loginMessage.classList.add('text-rose-500');
                return;
            }


            if (userFound) {
                // La sesión de Firebase Auth ya está activa (userCredential la inició)
                document.getElementById('loginSection').classList.add('hidden');
                document.getElementById('logoutButton').classList.remove('hidden');
                document.getElementById('addFunctionSection').classList.remove('hidden');
                document.getElementById('fixErrorSection').classList.remove('hidden');
                
                displayFunctions(); // Refresca botones de editar/eliminar

                // Mostrar secciones de administración
                document.getElementById('adminManagementSection').classList.remove('hidden');
                document.getElementById('notificationsSection').classList.remove('hidden');
                
                // Actualizar log y mensaje de bienvenida
                const userDataRef = doc(db, ADMINS_PATH, loggedInUser.uid);
                
                await sendWelcomeMessage(loggedInUser.lastLogin, loggedInUser.username);
                
                // Actualizamos o creamos el documento mínimo en ADMINS_PATH después de un login exitoso.
                // Esto garantiza que el 'lastLogin' y 'username' se guarden para la próxima sesión.
                await setDoc(userDataRef, { 
                    lastLogin: new Date(),
                    username: loggedInUser.username,
                    uid: loggedInUser.uid,
                    isAdmin: true // Lo mantenemos para consistencia en Firestore/Reglas
                }, { merge: true });

                showMessage(`¡Bienvenido, ${loggedInUser.username}! Has iniciado sesión con éxito.`, 'success');
                document.getElementById('welcomeMessage').classList.remove('hidden');
            }
        };


        const sendWelcomeMessage = async (lastLogin, username) => {
            const welcomeMessageDiv = document.getElementById('welcomeMessage');
            let actionsSummary = '';
            
            if (lastLogin) {
                const logsRef = collection(db, LOGS_PATH);
                const q = query(logsRef, where("user", "==", username));
                try {
                    const querySnapshot = await getDocs(q);

                    const recentActions = [];
                    querySnapshot.forEach(doc => {
                        const log = doc.data();
                        if (log.timestamp.toDate() > lastLogin.toDate()) {
                            recentActions.push(log);
    1. **Cargar la librería:** Agregamos `<script src="https://cdn.tailwindcss.com"></script>` al `<head>`.
    2. **Establecer el fondo y texto base:** Agregamos `class="bg-gray-100 font-sans leading-normal tracking-normal text-gray-800"` a la etiqueta `<body>`.

Aquí está el **código HTML completo y corregido**:

```html
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SQL Functions Repository</title>
        <script src="https://cdn.tailwindcss.com"></script>
   <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    // CAMBIO CLAVE: Importar funciones de Auth con Email/Password
    import { getAuth, signInAnonymously, signInWithCustomToken, signInWithEmailAndPassword, createUserWithEmailAndPassword, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, collection, addDoc, onSnapshot, doc, deleteDoc, updateDoc, getDocs, setDoc, getDoc, query, where } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // Configuración de Firebase (Se mantiene la configuración original del usuario)
    const firebaseConfig = {
        apiKey: "AIzaSyCeD4TAPK2GuW01J5WQl7vJjmJWC671f-Y",
        authDomain: "codigograbado.firebaseapp.com",
        projectId: "codigograbado",
        storageBucket: "codigograbado.firebasestorage.app",
        messagingSenderId: "346430888474",
        appId: "1:346430888474:web:cbaa641fbf4fc62bca4fa3",
        measurementId: "G-626THBS8CJ"
    };
    const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

    let db, auth, userId, loggedInUser = null;
    let functionsList = [];
    let editingId = null;
    let confirmActionCallback = null;
    // Variable para almacenar la acción pendiente de guardar después de la validación de Gemini
    let pendingSaveAction = null; 


    // SE ELIMINAN LAS CREDENCIALES CODIFICADAS DEL SUPER ADMIN
    const SUPER_ADMIN_KEY = 'DT10VazC;#9i'; // Clave Mantenida SOLO para PROMOCIÓN, no para LOGIN
    
    // Rutas de Firestore
    const DB_ROOT = `/artifacts/public/data/aTvZxvxzBtCnCNlURVrQ`;
    const FUNCTIONS_PATH = `${DB_ROOT}/sql_functions`;
    const ADMINS_PATH = `${DB_ROOT}/admins`;
    const LOGS_PATH = `${DB_ROOT}/logs`;
    const NOTIFICATIONS_PATH = `${DB_ROOT}/notifications`;


    // --- Funciones del Modal de Confirmación ---
    const showConfirmModal = (message, onConfirm) => {
        document.getElementById('confirmModalMessage').textContent = message;
        document.getElementById('confirmModal').classList.remove('hidden');
        document.getElementById('confirmModal').classList.add('flex');
        confirmActionCallback = onConfirm;
    };

    const hideConfirmModal = () => {
        document.getElementById('confirmModal').classList.add('hidden');
        document.getElementById('confirmModal').classList.remove('flex');
        confirmActionCallback = null;
    };

    const handleConfirm = (isConfirmed) => {
        if (isConfirmed && confirmActionCallback) {
            confirmActionCallback();
        }
        hideConfirmModal();
    };
    // --- Fin Funciones del Modal de Confirmación ---


    // Función para inicializar Firebase
    const initFirebase = async () => {
        try {
            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app); // Inicializa auth
            
            // Autenticación inicial (Anónima o con Custom Token)
            if (initialAuthToken) {
                await signInWithCustomToken(auth, initialAuthToken);
            } else {
                await signInAnonymously(auth); 
            }
            
            userId = auth.currentUser.uid;
            document.getElementById('userIdDisplay').textContent = `Tu ID de usuario: ${userId}`;
            
            console.log("Firebase inicializado y autenticación exitosa.");
            fetchFunctions();
            fetchNotifications();
        } catch (error) {
            console.error("Error al inicializar Firebase o autenticar:", error);
            showMessage("Error: No se pudo conectar a la base de datos.", 'error');
        }
    };

    const showMessage = (message, type = 'info') => {
        const statusMessage = document.getElementById('statusMessage');
        statusMessage.innerHTML = message;
        statusMessage.className = 'mt-4 text-center p-3 rounded-lg font-medium';
        if (type === 'error') {
            statusMessage.classList.add('bg-rose-200', 'text-rose-800');
        } else if (type === 'success') {
            statusMessage.classList.add('bg-emerald-200', 'text-emerald-800');
        } else {
            statusMessage.classList.add('bg-indigo-200', 'text-indigo-800');
        }
    };

    const fetchFunctions = () => {
        if (!db) return;
        const q = collection(db, FUNCTIONS_PATH);
        onSnapshot(q, (snapshot) => {
            functionsList = snapshot.docs.map(doc => ({
                id: doc.id,
                ...doc.data()
            }));
            displayFunctions();
        }, (error) => {
            console.error("Error al obtener funciones:", error);
            showMessage("Error al cargar las funciones.", 'error');
        });
    };

    const fetchNotifications = () => {
        if (!db || !userId) return;
        const q = collection(db, `${NOTIFICATIONS_PATH}/users/${userId}/notifications`);
        onSnapshot(q, (snapshot) => {
            const notifications = snapshot.docs.map(doc => ({id: doc.id, ...doc.data()}));
            displayNotifications(notifications);
        }, (error) => {
            console.error("Error al obtener notificaciones:", error);
        });
    };

    const addNotification = async (func) => {
        if (!userId) return;
        try {
            await addDoc(collection(db, `${NOTIFICATIONS_PATH}/users/${userId}/notifications`), {
                message: `Se ha agregado una nueva función: "${func.name}" con la descripción: "${func.description}".`,
                createdAt: new Date()
            });
        } catch (e) {
            console.error("Error al agregar notificación:", e);
        }
    };

    const displayNotifications = (notifications) => {
        const notificationsList = document.getElementById('notificationsList');
        if (!notificationsList) return;
        
        notificationsList.innerHTML = '';
        notifications.sort((a, b) => (b.createdAt?.toDate() || 0) - (a.createdAt?.toDate() || 0));
        
        if (notifications.length === 0) {
            notificationsList.innerHTML = '<p class="text-center text-gray-500 text-sm py-2">No hay notificaciones.</p>';
            return;
        }

        notifications.forEach(notif => {
            const date = notif.createdAt ? new Date(notif.createdAt.toDate()).toLocaleString() : 'Fecha desconocida';
            const notifItem = document.createElement('div');
            notifItem.className = 'bg-indigo-200 p-3 rounded-md mb-2';
            notifItem.innerHTML = `<p class="text-indigo-800 text-sm">${notif.message}</p>
                                     <span class="text-xs text-indigo-600">${date}</span>`;
            notificationsList.appendChild(notifItem);
        });
    };

    const displayFunctions = (functionsToDisplay = functionsList) => {
        const listElement = document.getElementById('functionsList');
        const searchList = document.getElementById('searchFunctionsList');
        listElement.innerHTML = '';
        searchList.innerHTML = '';

        const isUserLoggedIn = loggedInUser !== null;

        if (functionsToDisplay.length === 0) {
            listElement.innerHTML = '<p class="text-center text-gray-500">No se encontraron funciones.</p>';
        }

        functionsToDisplay.forEach(func => {
            const funcItem = document.createElement('div');
            funcItem.className = 'bg-gray-200 p-4 rounded-lg shadow-md mb-4';
            funcItem.innerHTML = `
                <h3 class="text-xl font-bold text-gray-800">${func.name}</h3>
                <p class="text-sm text-gray-600 mb-2"><strong>Descripción:</strong> ${func.description}</p>
                <div class="bg-white p-3 rounded-lg border border-gray-400 overflow-x-auto">
                    <pre class="whitespace-pre-wrap font-mono text-gray-800"><code>${func.syntax}</code></pre>
                </div>
                <div class="mt-4 flex space-x-2 ${isUserLoggedIn ? '' : 'hidden'}">
                    <button class="edit-btn bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200 text-sm" data-id="${func.id}">Editar</button>
                    <button class="delete-btn bg-rose-600 hover:bg-rose-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200 text-sm" data-id="${func.id}">Eliminar</button>
                </div>
            `;
            listElement.appendChild(funcItem);

            if (isUserLoggedIn) {
                funcItem.querySelector('.edit-btn').addEventListener('click', () => editFunction(func));
                funcItem.querySelector('.delete-btn').addEventListener('click', () => deleteFunction(func.id));
            }

            const searchItem = document.createElement('li');
            searchItem.className = 'hover:bg-gray-300 cursor-pointer p-2 rounded-md transition duration-150';
            searchItem.textContent = func.name;
            searchItem.onclick = () => {
                document.getElementById('descriptionSearch').value = func.description;
                document.getElementById('descriptionSearch').focus();
                showMessage(`Descripción de la función "${func.name}" cargada en el generador de consultas.`, 'info');
            };
            searchList.appendChild(searchItem);
        });
    };

    // --- FUNCIÓN DE VALIDACIÓN DE GEMINI MODIFICADA (CLAVE ACTUALIZADA) ---
    const validateFunctionWithAI = async (name, description, syntax) => {
        const apiKey = "AIzaSyB0h595ERkhyMS-GCoa5J6zsq_W440R6SM"; // <-- NUEVA CLAVE AQUÍ
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`; // Modelo cambiado a Flash
        
        const prompt = `Eres un experto en SQL y un editor de documentación de alta calidad. Tu tarea es validar una función de SQL que un administrador quiere agregar o editar.

Revisa los siguientes campos:
1.  Nombre de la Función: ${name}
2.  Descripción: ${description}
3.  Sintaxis: ${syntax}

Sigue estos pasos y proporciona la respuesta en formato JSON:
1.  **VERIFICACIÓN BÁSICA (Validación de Sintaxis):** ¿Es la sintaxis un código SQL válido (o un patrón de función SQL válido)? Si NO, establece "valid": false.
2.  **REVISIÓN DE COHERENCIA Y CALIDAD:**
    * Si la sintaxis es válida, revisa si la Descripción es completa y si la Sintaxis es el mejor ejemplo para la función.
    * Si la Descripción o la Sintaxis son subóptimas, genera una o dos sugerencias de mejora concisas.
    * Si hay sugerencias, genera una 'optimizedDescription' y 'optimizedSyntax' mejoradas.
3.  **SALIDA JSON:** Proporciona tu respuesta en el siguiente esquema JSON.

JSON Scheme:
{
  "valid": <boolean, true si la sintaxis es correcta; false si hay un error de sintaxis>,
  "suggestions": <string, Un mensaje conciso de mejora si la sintaxis es válida pero necesita pulirse, o vacío si es perfecto.>,
  "optimizedDescription": <string, La Descripción mejorada. Debe ser igual a la original si no hay sugerencias.>,
  "optimizedSyntax": <string, La Sintaxis mejorada. Debe ser igual a la original si no hay sugerencias.>
}
`;
            
        const payload = {
            contents: [{ parts: [{ text: prompt }] }],
            config: {
                responseMimeType: "application/json", // Forzar la respuesta JSON
            },
        };
            
        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            
            const result = await response.json();
            const text = result?.candidates?.[0]?.content?.parts?.[0]?.text || '';
            
            // Intentar parsear el JSON
            const jsonText = text.replace(/```json|```/g, '').trim();
            const validationData = JSON.parse(jsonText);

            return validationData;
        } catch (error) {
            console.error("Error al validar con IA:", error);
            return { valid: false, suggestions: "No se pudo validar con la IA. Error de conexión o API.", optimizedDescription: description, optimizedSyntax: syntax };
        }
    };

    // --- FUNCIÓN PARA MOSTRAR SUGERENCIAS EN MODAL (NUEVA) ---
    const showGeminiSuggestions = (validationData) => {
        const modal = document.getElementById('geminiModal');
        const messageEl = document.getElementById('geminiModalMessage');
        const suggestionsEl = document.getElementById('geminiSuggestionsBody');
        const acceptBtn = document.getElementById('geminiAcceptBtn');
        const rejectBtn = document.getElementById('geminiRejectBtn');
        
        messageEl.textContent = 'Gemini ha detectado mejoras en la función. ¿Deseas aplicarlas antes de guardar?';
        suggestionsEl.innerHTML = `
            <p class="text-indigo-700 font-semibold mb-2">Sugerencias de Gemini:</p>
            <p class="mb-4 text-gray-700">${validationData.suggestions}</p>
            
            <div class="bg-gray-100 p-3 rounded-lg border border-gray-300">
                <p class="font-bold text-sm text-gray-800">Descripción Optimizada:</p>
                <p class="text-sm text-gray-600">${validationData.optimizedDescription}</p>
            </div>
            <div class="bg-gray-100 p-3 rounded-lg border border-gray-300 mt-2">
                <p class="font-bold text-sm text-gray-800">Sintaxis Optimizada:</p>
                <pre class="text-sm text-gray-600 whitespace-pre-wrap">${validationData.optimizedSyntax}</pre>
            </div>
        `;
            
        modal.classList.remove('hidden');
        modal.classList.add('flex');
            
        // Manejadores de botones para aplicar o rechazar sugerencias
        acceptBtn.onclick = () => {
            document.getElementById('funcDescription').value = validationData.optimizedDescription;
            document.getElementById('funcSyntax').value = validationData.optimizedSyntax;
            hideGeminiModal();
            pendingSaveAction(); // Guarda el formulario con los datos optimizados
        };
            
        rejectBtn.onclick = () => {
            hideGeminiModal();
            pendingSaveAction(); // Guarda el formulario con los datos originales
        };
    };

    const hideGeminiModal = () => {
        document.getElementById('geminiModal').classList.add('hidden');
        document.getElementById('geminiModal').classList.remove('flex');
    };
    // --- FIN FUNCIÓN PARA MOSTRAR SUGERENCIAS EN MODAL ---

    // --- FUNCIÓN DE AGREGAR/ACTUALIZAR MODIFICADA ---
    const addOrUpdateFunction = async (event) => {
        event.preventDefault();
        const name = document.getElementById('funcName').value.trim();
        const description = document.getElementById('funcDescription').value.trim();
        const syntax = document.getElementById('funcSyntax').value.trim();
        const button = document.getElementById('addFunctionButton');
        const originalButtonText = editingId ? 'Actualizar Función' : 'Guardar Función';
            
        if (!loggedInUser) {
            showMessage('Debes iniciar sesión para realizar esta acción.', 'error');
            return;
        }

        if (!name || !description || !syntax) {
            showMessage('Todos los campos son obligatorios.', 'error');
            return;
        }

        // Esta es la función principal de guardado que se llamará después de la validación/sugerencia
        const saveFunction = async () => {
            // Recaptura los valores (pueden haber sido actualizados por el modal)
            const currentName = document.getElementById('funcName').value.trim();
            const currentDescription = document.getElementById('funcDescription').value.trim();
            const currentSyntax = document.getElementById('funcSyntax').value.trim();

            try {
                if (editingId) {
                    await updateDoc(doc(db, FUNCTIONS_PATH, editingId), {
                        name: currentName,
                        description: currentDescription,
                        syntax: currentSyntax,
                    });
                    await addDoc(collection(db, LOGS_PATH), {
                        action: "edited",
                        user: loggedInUser.username,
                        functionName: currentName,
                        timestamp: new Date()
                    });
                    showMessage(`Función actualizada con éxito.`, 'success');
                    editingId = null;
                    document.getElementById('addFunctionButton').textContent = 'Guardar Función';
                } else {
                    await addDoc(collection(db, FUNCTIONS_PATH), {
                        name: currentName,
                        description: currentDescription,
                        syntax: currentSyntax,
                        createdAt: new Date()
                    });
                    await addDoc(collection(db, LOGS_PATH), {
                        action: "added",
                        user: loggedInUser.username,
                        functionName: currentName,
                        timestamp: new Date()
                    });
                    showMessage(`Función agregada con éxito.`, 'success');
                    await addNotification({name: currentName, description: currentDescription, syntax: currentSyntax});
                }
                document.getElementById('addFunctionForm').reset();
            } catch (e) {
                console.error("Error al agregar/actualizar documento: ", e);
                showMessage("Error al guardar la función. Verifica la consola de Firebase.", 'error');
            } finally {
                button.textContent = originalButtonText;
                button.disabled = false;
            }
        };


        // --- FLUJO DE VALIDACIÓN INICIAL ---
        button.textContent = 'Validando con IA...';
        button.disabled = true;

        const validationResult = await validateFunctionWithAI(name, description, syntax);

        if (!validationResult.valid) {
            // Si hay un error de sintaxis FATAL, se cancela el proceso
            showMessage(`Error al agregar la información. Error de sintaxis: ${validationResult.suggestions || 'Sintaxis inválida.'}`, 'error');
            button.textContent = originalButtonText;
            button.disabled = false;
            return;
        }

        if (validationResult.suggestions && validationResult.suggestions.trim() !== '') {
            // Si hay sugerencias de mejora, mostrar modal
            pendingSaveAction = saveFunction; // Almacenar la acción de guardado
            showGeminiSuggestions(validationResult);
        } else {
            // Si es válido y no hay sugerencias, guardar directamente
            saveFunction();
        }
    };
    // --- FIN FUNCIÓN DE AGREGAR/ACTUALIZAR MODIFICADA ---

    const editFunction = (func) => {
        editingId = func.id;
        document.getElementById('funcName').value = func.name;
        document.getElementById('funcDescription').value = func.description;
        document.getElementById('funcSyntax').value = func.syntax;
        document.getElementById('addFunctionButton').textContent = 'Actualizar Función';
        document.getElementById('addFunctionSection').scrollIntoView({ behavior: 'smooth' });
    };

    const deleteFunction = async (id) => {
        if (!loggedInUser) {
            showMessage('Debes iniciar sesión para realizar esta acción.', 'error');
            return;
        }
        
        showConfirmModal('¿Estás seguro de que quieres eliminar esta función? Esta acción no se puede deshacer.', async () => {
            try {
                const docRef = doc(db, FUNCTIONS_PATH, id);
                const funcSnap = await getDoc(docRef);
                if (funcSnap.exists()) {
                    await deleteDoc(docRef);
                    await addDoc(collection(db, LOGS_PATH), {
                        action: "deleted",
                        user: loggedInUser.username,
                        functionName: funcSnap.data().name,
                        timestamp: new Date()
                    });
                    showMessage('Función eliminada con éxito.', 'success');
                }
            } catch (e) {
                console.error("Error al eliminar documento: ", e);
                showMessage("Error al eliminar la función.", 'error');
            }
        });
    };

    // Función de Creación de Administrador
    const createAdmin = async (event) => {
        event.preventDefault();
        const newAdminEmail = document.getElementById('newAdminEmail').value.trim();
        const newAdminPassword = document.getElementById('newAdminPassword').value;
        const newAdminUsername = document.getElementById('newAdminUsername').value.trim();
        const secretKey = document.getElementById('secretKey').value;
        const adminMessage = document.getElementById('adminMessage');

        adminMessage.textContent = '';
        adminMessage.className = 'mt-4 text-center text-sm';
        
        // La clave secreta ahora solo es obligatoria si el email ya existe
        const isPromotingExistingUser = secretKey === SUPER_ADMIN_KEY;
        
        if (!newAdminEmail || !newAdminPassword || !newAdminUsername) {
            adminMessage.textContent = 'Todos los campos son obligatorios.';
            adminMessage.classList.add('text-rose-500');
            return;
        }
        
        let uid = null;

        try {
            // 1. Intentar crear usuario en Firebase Authentication
            const userCredential = await createUserWithEmailAndPassword(auth, newAdminEmail, newAdminPassword);
            uid = userCredential.user.uid;
        } catch (e) {
            if (e.code === 'auth/email-already-in-use') {
                // Si el email ya está en uso, intentamos obtener el UID SÓLO si se proporciona la clave de promoción.
                if (isPromotingExistingUser) {
                    try {
                        // Temporalmente loguea al usuario para obtener el UID
                        const userCredential = await signInWithEmailAndPassword(auth, newAdminEmail, newAdminPassword);
                        uid = userCredential.user.uid;
                        // Cierra la sesión temporal para no interrumpir al Admin que está creando la cuenta.
                        await signOut(auth); 
                        adminMessage.textContent = 'Advertencia: El email ya existía. Se asignarán permisos de administrador.';
                    } catch (signInError) {
                         let displayError = 'Error: El email ya está registrado, pero la contraseña no coincide. No se puede obtener el UID para asignar permisos.';
                         adminMessage.textContent = displayError;
                         adminMessage.classList.add('text-rose-500');
                         return;
                    }
                } else {
                    adminMessage.textContent = 'Error: El email ya está registrado. Para promocionar a un usuario existente, ingrese la clave secreta.';
                    adminMessage.classList.add('text-rose-500');
                    return;
                }
            } else if (e.code === 'auth/weak-password') {
                adminMessage.textContent = 'Error: La contraseña debe tener al menos 6 caracteres.';
                adminMessage.classList.add('text-rose-500');
                return;
            } else {
                console.error("Error al crear usuario Auth:", e);
                adminMessage.textContent = `Error (${e.code || 'unknown-error'}): No se pudo crear la cuenta de usuario.`;
                adminMessage.classList.add('text-rose-500');
                return;
            }
        }
        
        if (!uid) { return; } // Salir si no se pudo obtener el UID.


            // 2. Registrar el rol en Firestore usando el UID (tanto para usuarios nuevos como existentes)
            try {
                await setDoc(doc(db, ADMINS_PATH, uid), {
                    uid: uid,
                    username: newAdminUsername,
                    email: newAdminEmail,
                    isAdmin: true, // Establecer como true para que sea admin de Firestore
                    lastLogin: null
                }, { merge: true }); // Usar merge: true para no sobrescribir lastLogin si ya existe.

                if (!adminMessage.classList.contains('text-yellow-500')) {
                    adminMessage.textContent = `Administrador ${newAdminUsername} creado con éxito. Ahora puede iniciar sesión con su email y contraseña.`;
                    adminMessage.classList.add('text-emerald-500');
                }
                document.getElementById('createAdminForm').reset();
            } catch (e) {
                console.error("Error al registrar administrador en Firestore:", e);
                adminMessage.textContent = 'Error: Se creó la cuenta de Auth, pero falló el registro de permisos en Firestore.';
                adminMessage.classList.add('text-rose-500');
            }
        };

        const logout = async () => {
            try {
                // Siempre cierra la sesión de Firebase Auth, si existe.
                if (auth.currentUser) {
                    await signOut(auth);
                }
                
                // Reseteamos el estado de la aplicación
                loggedInUser = null; 

                // Ocultar secciones de administración
                document.getElementById('addFunctionSection').classList.add('hidden');
                document.getElementById('fixErrorSection').classList.add('hidden');
                document.getElementById('adminManagementSection').classList.add('hidden');
                document.getElementById('notificationsSection').classList.add('hidden');
                document.getElementById('logoutButton').classList.add('hidden');
                document.getElementById('welcomeMessage').classList.add('hidden');

                // Volver a iniciar sesión anónima para acceder a funciones de lectura pública
                await signInAnonymously(auth);
                userId = auth.currentUser.uid;
                document.getElementById('userIdDisplay').textContent = `Tu ID de usuario: ${userId}`;

                // Mostrar sección de login y refrescar lista para ocultar botones de editar/eliminar
                document.getElementById('loginSection').classList.remove('hidden');
                displayFunctions(); 

                showMessage('Sesión cerrada correctamente.', 'info');
            } catch (error) {
                console.error("Error al cerrar sesión o al re-autenticar anónimamente:", error);
                showMessage('Error al cerrar sesión.', 'error');
            }
        };

        // MODIFICACIÓN CRÍTICA: Se elimina la verificación estricta del rol de Firestore.
        const login = async (event) => {
            event.preventDefault();
            const loginEmail = document.getElementById('loginEmail').value.trim();
            const loginPassword = document.getElementById('loginPassword').value;
            const loginMessage = document.getElementById('loginMessage');
            
            loginMessage.textContent = '';
            loggedInUser = null; 
            
            let userFound = false;
            let uid = null;

            try {
                // 1. Intento de inicio de sesión de Firebase Auth (Email/Password)
                const userCredential = await signInWithEmailAndPassword(auth, loginEmail, loginPassword);
                const user = userCredential.user;
                uid = user.uid;

                // 2. ASUMIMOS QUE EL USUARIO AUTENTICADO ES EL ADMIN (QUITANDO LA VERIFICACIÓN DEL ROL)
                loggedInUser = { 
                    uid: uid,
                    // Usamos la parte del email antes del @ como nombre de usuario por defecto
                    username: loginEmail.split('@')[0], 
                    isAdmin: true, // Asumir permisos de administrador
                    lastLogin: null // Se obtendrá y actualizará después
                };
    1. **Cargar la librería:** Agregamos `<script src="https://cdn.tailwindcss.com"></script>` al `<head>`.
    2. **Establecer el fondo y texto base:** Agregamos `class="bg-gray-100 font-sans leading-normal tracking-normal text-gray-800"` a la etiqueta `<body>`.

Aquí está el **código HTML completo y corregido**:

```html
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SQL Functions Repository</title>
        <script src="[https://cdn.tailwindcss.com](https://cdn.tailwindcss.com)"></script>
   <script type="module">
    import { initializeApp } from "[https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js](https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js)";
    // CAMBIO CLAVE: Importar funciones de Auth con Email/Password
    import { getAuth, signInAnonymously, signInWithCustomToken, signInWithEmailAndPassword, createUserWithEmailAndPassword, signOut } from "[https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js](https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js)";
    import { getFirestore, collection, addDoc, onSnapshot, doc, deleteDoc, updateDoc, getDocs, setDoc, getDoc, query, where } from "[https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js](https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js)";

    // Configuración de Firebase (Se mantiene la configuración original del usuario)
    const firebaseConfig = {
        apiKey: "AIzaSyCeD4TAPK2GuW01J5WQl7vJjmJWC671f-Y",
        authDomain: "codigograbado.firebaseapp.com",
        projectId: "codigograbado",
        storageBucket: "codigograbado.firebasestorage.app",
        messagingSenderId: "346430888474",
        appId: "1:346430888474:web:cbaa641fbf4fc62bca4fa3",
        measurementId: "G-626THBS8CJ"
    };
    const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

    let db, auth, userId, loggedInUser = null;
    let functionsList = [];
    let editingId = null;
    let confirmActionCallback = null;
    // Variable para almacenar la acción pendiente de guardar después de la validación de Gemini
    let pendingSaveAction = null; 


    // SE ELIMINAN LAS CREDENCIALES CODIFICADAS DEL SUPER ADMIN
    const SUPER_ADMIN_KEY = 'DT10VazC;#9i'; // Clave Mantenida SOLO para PROMOCIÓN, no para LOGIN
    
    // Rutas de Firestore
    const DB_ROOT = `/artifacts/public/data/aTvZxvxzBtCnCNlURVrQ`;
    const FUNCTIONS_PATH = `${DB_ROOT}/sql_functions`;
    const ADMINS_PATH = `${DB_ROOT}/admins`;
    const LOGS_PATH = `${DB_ROOT}/logs`;
    const NOTIFICATIONS_PATH = `${DB_ROOT}/notifications`;


    // --- Funciones del Modal de Confirmación ---
    const showConfirmModal = (message, onConfirm) => {
        document.getElementById('confirmModalMessage').textContent = message;
        document.getElementById('confirmModal').classList.remove('hidden');
        document.getElementById('confirmModal').classList.add('flex');
        confirmActionCallback = onConfirm;
    };

    const hideConfirmModal = () => {
        document.getElementById('confirmModal').classList.add('hidden');
        document.getElementById('confirmModal').classList.remove('flex');
        confirmActionCallback = null;
    };

    const handleConfirm = (isConfirmed) => {
        if (isConfirmed && confirmActionCallback) {
            confirmActionCallback();
        }
        hideConfirmModal();
    };
    // --- Fin Funciones del Modal de Confirmación ---


    // Función para inicializar Firebase
    const initFirebase = async () => {
        try {
            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app); // Inicializa auth
            
            // Autenticación inicial (Anónima o con Custom Token)
            if (initialAuthToken) {
                await signInWithCustomToken(auth, initialAuthToken);
            } else {
                await signInAnonymously(auth); 
            }
            
            userId = auth.currentUser.uid;
            document.getElementById('userIdDisplay').textContent = `Tu ID de usuario: ${userId}`;
            
            console.log("Firebase inicializado y autenticación exitosa.");
            fetchFunctions();
            fetchNotifications();
        } catch (error) {
            console.error("Error al inicializar Firebase o autenticar:", error);
            showMessage("Error: No se pudo conectar a la base de datos.", 'error');
        }
    };

    const showMessage = (message, type = 'info') => {
        const statusMessage = document.getElementById('statusMessage');
        statusMessage.innerHTML = message;
        statusMessage.className = 'mt-4 text-center p-3 rounded-lg font-medium';
        if (type === 'error') {
            statusMessage.classList.add('bg-rose-200', 'text-rose-800');
        } else if (type === 'success') {
            statusMessage.classList.add('bg-emerald-200', 'text-emerald-800');
        } else {
            statusMessage.classList.add('bg-indigo-200', 'text-indigo-800');
        }
    };

    const fetchFunctions = () => {
        if (!db) return;
        const q = collection(db, FUNCTIONS_PATH);
        onSnapshot(q, (snapshot) => {
            functionsList = snapshot.docs.map(doc => ({
                id: doc.id,
                ...doc.data()
            }));
            displayFunctions();
        }, (error) => {
            console.error("Error al obtener funciones:", error);
            showMessage("Error al cargar las funciones.", 'error');
        });
    };

    const fetchNotifications = () => {
        if (!db || !userId) return;
        const q = collection(db, `${NOTIFICATIONS_PATH}/users/${userId}/notifications`);
        onSnapshot(q, (snapshot) => {
            const notifications = snapshot.docs.map(doc => ({id: doc.id, ...doc.data()}));
            displayNotifications(notifications);
        }, (error) => {
            console.error("Error al obtener notificaciones:", error);
        });
    };

    const addNotification = async (func) => {
        if (!userId) return;
        try {
            await addDoc(collection(db, `${NOTIFICATIONS_PATH}/users/${userId}/notifications`), {
                message: `Se ha agregado una nueva función: "${func.name}" con la descripción: "${func.description}".`,
                createdAt: new Date()
            });
        } catch (e) {
            console.error("Error al agregar notificación:", e);
        }
    };

    const displayNotifications = (notifications) => {
        const notificationsList = document.getElementById('notificationsList');
        if (!notificationsList) return;
        
        notificationsList.innerHTML = '';
        notifications.sort((a, b) => (b.createdAt?.toDate() || 0) - (a.createdAt?.toDate() || 0));
        
        if (notifications.length === 0) {
            notificationsList.innerHTML = '<p class="text-center text-gray-500 text-sm py-2">No hay notificaciones.</p>';
            return;
        }

        notifications.forEach(notif => {
            const date = notif.createdAt ? new Date(notif.createdAt.toDate()).toLocaleString() : 'Fecha desconocida';
            const notifItem = document.createElement('div');
            notifItem.className = 'bg-indigo-200 p-3 rounded-md mb-2';
            notifItem.innerHTML = `<p class="text-indigo-800 text-sm">${notif.message}</p>
                                     <span class="text-xs text-indigo-600">${date}</span>`;
            notificationsList.appendChild(notifItem);
        });
    };

    const displayFunctions = (functionsToDisplay = functionsList) => {
        const listElement = document.getElementById('functionsList');
        const searchList = document.getElementById('searchFunctionsList');
        listElement.innerHTML = '';
        searchList.innerHTML = '';

        const isUserLoggedIn = loggedInUser !== null;

        if (functionsToDisplay.length === 0) {
            listElement.innerHTML = '<p class="text-center text-gray-500">No se encontraron funciones.</p>';
        }

        functionsToDisplay.forEach(func => {
            const funcItem = document.createElement('div');
            funcItem.className = 'bg-gray-200 p-4 rounded-lg shadow-md mb-4';
            funcItem.innerHTML = `
                <h3 class="text-xl font-bold text-gray-800">${func.name}</h3>
                <p class="text-sm text-gray-600 mb-2"><strong>Descripción:</strong> ${func.description}</p>
                <div class="bg-white p-3 rounded-lg border border-gray-400 overflow-x-auto">
                    <pre class="whitespace-pre-wrap font-mono text-gray-800"><code>${func.syntax}</code></pre>
                </div>
                <div class="mt-4 flex space-x-2 ${isUserLoggedIn ? '' : 'hidden'}">
                    <button class="edit-btn bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200 text-sm" data-id="${func.id}">Editar</button>
                    <button class="delete-btn bg-rose-600 hover:bg-rose-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200 text-sm" data-id="${func.id}">Eliminar</button>
                </div>
            `;
            listElement.appendChild(funcItem);

            if (isUserLoggedIn) {
                funcItem.querySelector('.edit-btn').addEventListener('click', () => editFunction(func));
                funcItem.querySelector('.delete-btn').addEventListener('click', () => deleteFunction(func.id));
            }

            const searchItem = document.createElement('li');
            searchItem.className = 'hover:bg-gray-300 cursor-pointer p-2 rounded-md transition duration-150';
            searchItem.textContent = func.name;
            searchItem.onclick = () => {
                document.getElementById('descriptionSearch').value = func.description;
                document.getElementById('descriptionSearch').focus();
                showMessage(`Descripción de la función "${func.name}" cargada en el generador de consultas.`, 'info');
            };
            searchList.appendChild(searchItem);
        });
    };

    // --- FUNCIÓN DE VALIDACIÓN DE GEMINI MODIFICADA (CLAVE ACTUALIZADA) ---
    const validateFunctionWithAI = async (name, description, syntax) => {
        const apiKey = "AIzaSyB0h595ERkhyMS-GCoa5J6zsq_W440R6SM"; // <-- NUEVA CLAVE AQUÍ
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`; // Modelo cambiado a Flash
        
        const prompt = `Eres un experto en SQL y un editor de documentación de alta calidad. Tu tarea es validar una función de SQL que un administrador quiere agregar o editar.

Revisa los siguientes campos:
1.  Nombre de la Función: ${name}
2.  Descripción: ${description}
3.  Sintaxis: ${syntax}

Sigue estos pasos y proporciona la respuesta en formato JSON:
1.  **VERIFICACIÓN BÁSICA (Validación de Sintaxis):** ¿Es la sintaxis un código SQL válido (o un patrón de función SQL válido)? Si NO, establece "valid": false.
2.  **REVISIÓN DE COHERENCIA Y CALIDAD:**
    * Si la sintaxis es válida, revisa si la Descripción es completa y si la Sintaxis es el mejor ejemplo para la función.
    * Si la Descripción o la Sintaxis son subóptimas, genera una o dos sugerencias de mejora concisas.
    * Si hay sugerencias, genera una 'optimizedDescription' y 'optimizedSyntax' mejoradas.
3.  **SALIDA JSON:** Proporciona tu respuesta en el siguiente esquema JSON.

JSON Scheme:
{
  "valid": <boolean, true si la sintaxis es correcta; false si hay un error de sintaxis>,
  "suggestions": <string, Un mensaje conciso de mejora si la sintaxis es válida pero necesita pulirse, o vacío si es perfecto.>,
  "optimizedDescription": <string, La Descripción mejorada. Debe ser igual a la original si no hay sugerencias.>,
  "optimizedSyntax": <string, La Sintaxis mejorada. Debe ser igual a la original si no hay sugerencias.>
}
`;
            
        const payload = {
            contents: [{ parts: [{ text: prompt }] }],
            config: {
                responseMimeType: "application/json", // Forzar la respuesta JSON
            },
        };
            
        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            
            const result = await response.json();
            const text = result?.candidates?.[0]?.content?.parts?.[0]?.text || '';
            
            // Intentar parsear el JSON
            const jsonText = text.replace(/```json|```/g, '').trim();
            const validationData = JSON.parse(jsonText);

            return validationData;
        } catch (error) {
            console.error("Error al validar con IA:", error);
            return { valid: false, suggestions: "No se pudo validar con la IA. Error de conexión o API.", optimizedDescription: description, optimizedSyntax: syntax };
        }
    };

    // --- FUNCIÓN PARA MOSTRAR SUGERENCIAS EN MODAL (NUEVA) ---
    const showGeminiSuggestions = (validationData) => {
        const modal = document.getElementById('geminiModal');
        const messageEl = document.getElementById('geminiModalMessage');
        const suggestionsEl = document.getElementById('geminiSuggestionsBody');
        const acceptBtn = document.getElementById('geminiAcceptBtn');
        const rejectBtn = document.getElementById('geminiRejectBtn');
        
        messageEl.textContent = 'Gemini ha detectado mejoras en la función. ¿Deseas aplicarlas antes de guardar?';
        suggestionsEl.innerHTML = `
            <p class="text-indigo-700 font-semibold mb-2">Sugerencias de Gemini:</p>
            <p class="mb-4 text-gray-700">${validationData.suggestions}</p>
            
            <div class="bg-gray-100 p-3 rounded-lg border border-gray-300">
                <p class="font-bold text-sm text-gray-800">Descripción Optimizada:</p>
                <p class="text-sm text-gray-600">${validationData.optimizedDescription}</p>
            </div>
            <div class="bg-gray-100 p-3 rounded-lg border border-gray-300 mt-2">
                <p class="font-bold text-sm text-gray-800">Sintaxis Optimizada:</p>
                <pre class="text-sm text-gray-600 whitespace-pre-wrap">${validationData.optimizedSyntax}</pre>
            </div>
        `;
            
        modal.classList.remove('hidden');
        modal.classList.add('flex');
            
        // Manejadores de botones para aplicar o rechazar sugerencias
        acceptBtn.onclick = () => {
            document.getElementById('funcDescription').value = validationData.optimizedDescription;
            document.getElementById('funcSyntax').value = validationData.optimizedSyntax;
            hideGeminiModal();
            pendingSaveAction(); // Guarda el formulario con los datos optimizados
        };
            
        rejectBtn.onclick = () => {
            hideGeminiModal();
            pendingSaveAction(); // Guarda el formulario con los datos originales
        };
    };

    const hideGeminiModal = () => {
        document.getElementById('geminiModal').classList.add('hidden');
        document.getElementById('geminiModal').classList.remove('flex');
    };
    // --- FIN FUNCIÓN PARA MOSTRAR SUGERENCIAS EN MODAL ---

    // --- FUNCIÓN DE AGREGAR/ACTUALIZAR MODIFICADA ---
    const addOrUpdateFunction = async (event) => {
        event.preventDefault();
        const name = document.getElementById('funcName').value.trim();
        const description = document.getElementById('funcDescription').value.trim();
        const syntax = document.getElementById('funcSyntax').value.trim();
        const button = document.getElementById('addFunctionButton');
        const originalButtonText = editingId ? 'Actualizar Función' : 'Guardar Función';
            
        if (!loggedInUser) {
            showMessage('Debes iniciar sesión para realizar esta acción.', 'error');
            return;
        }

        if (!name || !description || !syntax) {
            showMessage('Todos los campos son obligatorios.', 'error');
            return;
        }

        // Esta es la función principal de guardado que se llamará después de la validación/sugerencia
        const saveFunction = async () => {
            // Recaptura los valores (pueden haber sido actualizados por el modal)
            const currentName = document.getElementById('funcName').value.trim();
            const currentDescription = document.getElementById('funcDescription').value.trim();
            const currentSyntax = document.getElementById('funcSyntax').value.trim();

            try {
                if (editingId) {
                    await updateDoc(doc(db, FUNCTIONS_PATH, editingId), {
                        name: currentName,
                        description: currentDescription,
                        syntax: currentSyntax,
                    });
                    await addDoc(collection(db, LOGS_PATH), {
                        action: "edited",
                        user: loggedInUser.username,
                        functionName: currentName,
                        timestamp: new Date()
                    });
                    showMessage(`Función actualizada con éxito.`, 'success');
                    editingId = null;
                    document.getElementById('addFunctionButton').textContent = 'Guardar Función';
                } else {
                    await addDoc(collection(db, FUNCTIONS_PATH), {
                        name: currentName,
                        description: currentDescription,
                        syntax: currentSyntax,
                        createdAt: new Date()
                    });
                    await addDoc(collection(db, LOGS_PATH), {
                        action: "added",
                        user: loggedInUser.username,
                        functionName: currentName,
                        timestamp: new Date()
                    });
                    showMessage(`Función agregada con éxito.`, 'success');
                    await addNotification({name: currentName, description: currentDescription, syntax: currentSyntax});
                }
                document.getElementById('addFunctionForm').reset();
            } catch (e) {
                console.error("Error al agregar/actualizar documento: ", e);
                showMessage("Error al guardar la función. Verifica la consola de Firebase.", 'error');
            } finally {
                button.textContent = originalButtonText;
                button.disabled = false;
            }
        };


        // --- FLUJO DE VALIDACIÓN INICIAL ---
        button.textContent = 'Validando con IA...';
        button.disabled = true;

        const validationResult = await validateFunctionWithAI(name, description, syntax);

        if (!validationResult.valid) {
            // Si hay un error de sintaxis FATAL, se cancela el proceso
            showMessage(`Error al agregar la información. Error de sintaxis: ${validationResult.suggestions || 'Sintaxis inválida.'}`, 'error');
            button.textContent = originalButtonText;
            button.disabled = false;
            return;
        }

        if (validationResult.suggestions && validationResult.suggestions.trim() !== '') {
            // Si hay sugerencias de mejora, mostrar modal
            pendingSaveAction = saveFunction; // Almacenar la acción de guardado
            showGeminiSuggestions(validationResult);
        } else {
            // Si es válido y no hay sugerencias, guardar directamente
            saveFunction();
        }
    };
    // --- FIN FUNCIÓN DE AGREGAR/ACTUALIZAR MODIFICADA ---

    const editFunction = (func) => {
        editingId = func.id;
        document.getElementById('funcName').value = func.name;
        document.getElementById('funcDescription').value = func.description;
        document.getElementById('funcSyntax').value = func.syntax;
        document.getElementById('addFunctionButton').textContent = 'Actualizar Función';
        document.getElementById('addFunctionSection').scrollIntoView({ behavior: 'smooth' });
    };

    const deleteFunction = async (id) => {
        if (!loggedInUser) {
            showMessage('Debes iniciar sesión para realizar esta acción.', 'error');
            return;
        }
        
        showConfirmModal('¿Estás seguro de que quieres eliminar esta función? Esta acción no se puede deshacer.', async () => {
            try {
    1. **Cargar la librería:** Agregamos `<script src="https://cdn.tailwindcss.com"></script>` al `<head>`.
    2. **Establecer el fondo y texto base:** Agregamos `class="bg-gray-100 font-sans leading-normal tracking-normal text-gray-800"` a la etiqueta `<body>`.

Aquí está el **código HTML completo y corregido**:

```html
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SQL Functions Repository</title>
        <script src="https://cdn.tailwindcss.com"></script>
   <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    // CAMBIO CLAVE: Importar funciones de Auth con Email/Password
    import { getAuth, signInAnonymously, signInWithCustomToken, signInWithEmailAndPassword, createUserWithEmailAndPassword, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, collection, addDoc, onSnapshot, doc, deleteDoc, updateDoc, getDocs, setDoc, getDoc, query, where } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // Configuración de Firebase (Se mantiene la configuración original del usuario)
    const firebaseConfig = {
        apiKey: "AIzaSyCeD4TAPK2GuW01J5WQl7vJjmJWC671f-Y",
        authDomain: "codigograbado.firebaseapp.com",
        projectId: "codigograbado",
        storageBucket: "codigograbado.firebasestorage.app",
        messagingSenderId: "346430888474",
        appId: "1:346430888474:web:cbaa641fbf4fc62bca4fa3",
        measurementId: "G-626THBS8CJ"
    };
    const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

    let db, auth, userId, loggedInUser = null;
    let functionsList = [];
    let editingId = null;
    let confirmActionCallback = null;
    // Variable para almacenar la acción pendiente de guardar después de la validación de Gemini
    let pendingSaveAction = null; 


    // SE ELIMINAN LAS CREDENCIALES CODIFICADAS DEL SUPER ADMIN
    const SUPER_ADMIN_KEY = 'DT10VazC;#9i'; // Clave Mantenida SOLO para PROMOCIÓN, no para LOGIN
    
    // Rutas de Firestore
    const DB_ROOT = `/artifacts/public/data/aTvZxvxzBtCnCNlURVrQ`;
    const FUNCTIONS_PATH = `${DB_ROOT}/sql_functions`;
    const ADMINS_PATH = `${DB_ROOT}/admins`;
    const LOGS_PATH = `${DB_ROOT}/logs`;
    const NOTIFICATIONS_PATH = `${DB_ROOT}/notifications`;


    // --- Funciones del Modal de Confirmación ---
    const showConfirmModal = (message, onConfirm) => {
        document.getElementById('confirmModalMessage').textContent = message;
        document.getElementById('confirmModal').classList.remove('hidden');
        document.getElementById('confirmModal').classList.add('flex');
        confirmActionCallback = onConfirm;
    };

    const hideConfirmModal = () => {
        document.getElementById('confirmModal').classList.add('hidden');
        document.getElementById('confirmModal').classList.remove('flex');
        confirmActionCallback = null;
    };

    const handleConfirm = (isConfirmed) => {
        if (isConfirmed && confirmActionCallback) {
            confirmActionCallback();
        }
        hideConfirmModal();
    };
    // --- Fin Funciones del Modal de Confirmación ---


    // Función para inicializar Firebase
    const initFirebase = async () => {
        try {
            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app); // Inicializa auth
            
            // Autenticación inicial (Anónima o con Custom Token)
            if (initialAuthToken) {
                await signInWithCustomToken(auth, initialAuthToken);
            } else {
                await signInAnonymously(auth); 
            }
            
            userId = auth.currentUser.uid;
            document.getElementById('userIdDisplay').textContent = `Tu ID de usuario: ${userId}`;
            
            console.log("Firebase inicializado y autenticación exitosa.");
            fetchFunctions();
            fetchNotifications();
        } catch (error) {
            console.error("Error al inicializar Firebase o autenticar:", error);
            showMessage("Error: No se pudo conectar a la base de datos.", 'error');
        }
    };

    const showMessage = (message, type = 'info') => {
        const statusMessage = document.getElementById('statusMessage');
        statusMessage.innerHTML = message;
        statusMessage.className = 'mt-4 text-center p-3 rounded-lg font-medium';
        if (type === 'error') {
            statusMessage.classList.add('bg-rose-200', 'text-rose-800');
        } else if (type === 'success') {
            statusMessage.classList.add('bg-emerald-200', 'text-emerald-800');
        } else {
            statusMessage.classList.add('bg-indigo-200', 'text-indigo-800');
        }
    };

    const fetchFunctions = () => {
        if (!db) return;
        const q = collection(db, FUNCTIONS_PATH);
        onSnapshot(q, (snapshot) => {
            functionsList = snapshot.docs.map(doc => ({
                id: doc.id,
                ...doc.data()
            }));
            displayFunctions();
        }, (error) => {
            console.error("Error al obtener funciones:", error);
            showMessage("Error al cargar las funciones.", 'error');
        });
    };

    const fetchNotifications = () => {
        if (!db || !userId) return;
        const q = collection(db, `${NOTIFICATIONS_PATH}/users/${userId}/notifications`);
        onSnapshot(q, (snapshot) => {
            const notifications = snapshot.docs.map(doc => ({id: doc.id, ...doc.data()}));
            displayNotifications(notifications);
        }, (error) => {
            console.error("Error al obtener notificaciones:", error);
        });
    };

    const addNotification = async (func) => {
        if (!userId) return;
        try {
            await addDoc(collection(db, `${NOTIFICATIONS_PATH}/users/${userId}/notifications`), {
                message: `Se ha agregado una nueva función: "${func.name}" con la descripción: "${func.description}".`,
                createdAt: new Date()
            });
        } catch (e) {
            console.error("Error al agregar notificación:", e);
        }
    };

    const displayNotifications = (notifications) => {
        const notificationsList = document.getElementById('notificationsList');
        if (!notificationsList) return;
        
        notificationsList.innerHTML = '';
        notifications.sort((a, b) => (b.createdAt?.toDate() || 0) - (a.createdAt?.toDate() || 0));
        
        if (notifications.length === 0) {
            notificationsList.innerHTML = '<p class="text-center text-gray-500 text-sm py-2">No hay notificaciones.</p>';
            return;
        }

        notifications.forEach(notif => {
            const date = notif.createdAt ? new Date(notif.createdAt.toDate()).toLocaleString() : 'Fecha desconocida';
            const notifItem = document.createElement('div');
            notifItem.className = 'bg-indigo-200 p-3 rounded-md mb-2';
            notifItem.innerHTML = `<p class="text-indigo-800 text-sm">${notif.message}</p>
                                     <span class="text-xs text-indigo-600">${date}</span>`;
            notificationsList.appendChild(notifItem);
        });
    };

    const displayFunctions = (functionsToDisplay = functionsList) => {
        const listElement = document.getElementById('functionsList');
        const searchList = document.getElementById('searchFunctionsList');
        listElement.innerHTML = '';
        searchList.innerHTML = '';

        const isUserLoggedIn = loggedInUser !== null;

        if (functionsToDisplay.length === 0) {
            listElement.innerHTML = '<p class="text-center text-gray-500">No se encontraron funciones.</p>';
        }

        functionsToDisplay.forEach(func => {
            const funcItem = document.createElement('div');
            funcItem.className = 'bg-gray-200 p-4 rounded-lg shadow-md mb-4';
            funcItem.innerHTML = `
                <h3 class="text-xl font-bold text-gray-800">${func.name}</h3>
                <p class="text-sm text-gray-600 mb-2"><strong>Descripción:</strong> ${func.description}</p>
                <div class="bg-white p-3 rounded-lg border border-gray-400 overflow-x-auto">
                    <pre class="whitespace-pre-wrap font-mono text-gray-800"><code>${func.syntax}</code></pre>
                </div>
                <div class="mt-4 flex space-x-2 ${isUserLoggedIn ? '' : 'hidden'}">
                    <button class="edit-btn bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200 text-sm" data-id="${func.id}">Editar</button>
                    <button class="delete-btn bg-rose-600 hover:bg-rose-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200 text-sm" data-id="${func.id}">Eliminar</button>
                </div>
            `;
            listElement.appendChild(funcItem);

            if (isUserLoggedIn) {
                funcItem.querySelector('.edit-btn').addEventListener('click', () => editFunction(func));
                funcItem.querySelector('.delete-btn').addEventListener('click', () => deleteFunction(func.id));
            }

            const searchItem = document.createElement('li');
            searchItem.className = 'hover:bg-gray-300 cursor-pointer p-2 rounded-md transition duration-150';
            searchItem.textContent = func.name;
            searchItem.onclick = () => {
                document.getElementById('descriptionSearch').value = func.description;
                document.getElementById('descriptionSearch').focus();
                showMessage(`Descripción de la función "${func.name}" cargada en el generador de consultas.`, 'info');
            };
            searchList.appendChild(searchItem);
        });
    };

    // --- FUNCIÓN DE VALIDACIÓN DE GEMINI MODIFICADA (CLAVE ACTUALIZADA) ---
    const validateFunctionWithAI = async (name, description, syntax) => {
        const apiKey = "AIzaSyB0h595ERkhyMS-GCoa5J6zsq_W440R6SM"; // <-- NUEVA CLAVE AQUÍ
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`; // Modelo cambiado a Flash
        
        const prompt = `Eres un experto en SQL y un editor de documentación de alta calidad. Tu tarea es validar una función de SQL que un administrador quiere agregar o editar.

Revisa los siguientes campos:
1.  Nombre de la Función: ${name}
2.  Descripción: ${description}
3.  Sintaxis: ${syntax}

Sigue estos pasos y proporciona la respuesta en formato JSON:
1.  **VERIFICACIÓN BÁSICA (Validación de Sintaxis):** ¿Es la sintaxis un código SQL válido (o un patrón de función SQL válido)? Si NO, establece "valid": false.
2.  **REVISIÓN DE COHERENCIA Y CALIDAD:**
    * Si la sintaxis es válida, revisa si la Descripción es completa y si la Sintaxis es el mejor ejemplo para la función.
    * Si la Descripción o la Sintaxis son subóptimas, genera una o dos sugerencias de mejora concisas.
    * Si hay sugerencias, genera una 'optimizedDescription' y 'optimizedSyntax' mejoradas.
3.  **SALIDA JSON:** Proporciona tu respuesta en el siguiente esquema JSON.

JSON Scheme:
{
  "valid": <boolean, true si la sintaxis es correcta; false si hay un error de sintaxis>,
  "suggestions": <string, Un mensaje conciso de mejora si la sintaxis es válida pero necesita pulirse, o vacío si es perfecto.>,
  "optimizedDescription": <string, La Descripción mejorada. Debe ser igual a la original si no hay sugerencias.>,
  "optimizedSyntax": <string, La Sintaxis mejorada. Debe ser igual a la original si no hay sugerencias.>
}
`;
            
        const payload = {
            contents: [{ parts: [{ text: prompt }] }],
            config: {
                responseMimeType: "application/json", // Forzar la respuesta JSON
            },
        };
            
        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            
            const result = await response.json();
            const text = result?.candidates?.[0]?.content?.parts?.[0]?.text || '';
            
            // Intentar parsear el JSON
            const jsonText = text.replace(/```json|```/g, '').trim();
            const validationData = JSON.parse(jsonText);

            return validationData;
        } catch (error) {
            console.error("Error al validar con IA:", error);
            return { valid: false, suggestions: "No se pudo validar con la IA. Error de conexión o API.", optimizedDescription: description, optimizedSyntax: syntax };
        }
    };

    // --- FUNCIÓN PARA MOSTRAR SUGERENCIAS EN MODAL (NUEVA) ---
    const showGeminiSuggestions = (validationData) => {
        const modal = document.getElementById('geminiModal');
        const messageEl = document.getElementById('geminiModalMessage');
        const suggestionsEl = document.getElementById('geminiSuggestionsBody');
        const acceptBtn = document.getElementById('geminiAcceptBtn');
        const rejectBtn = document.getElementById('geminiRejectBtn');
        
        messageEl.textContent = 'Gemini ha detectado mejoras en la función. ¿Deseas aplicarlas antes de guardar?';
        suggestionsEl.innerHTML = `
